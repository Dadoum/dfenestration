/++
 +  Module generated by wayland:scanner-v0.3.1 for xdg_toplevel_drag_v1 protocol
 +    xml protocol:   xdg-toplevel-drag-v1.xml
 +    generated code: client
 +/
module xdgtopleveldrag;
import xdgshell;
/+
 +  Protocol copyright:
 +
 +  Copyright 2023 David Redondo
 +
 +  Permission is hereby granted, free of charge, to any person obtaining a
 +  copy of this software and associated documentation files (the "Software"),
 +  to deal in the Software without restriction, including without limitation
 +  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 +  and/or sell copies of the Software, and to permit persons to whom the
 +  Software is furnished to do so, subject to the following conditions:
 +
 +  The above copyright notice and this permission notice (including the next
 +  paragraph) shall be included in all copies or substantial portions of the
 +  Software.
 +
 +  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 +  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 +  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 +  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 +  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 +  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 +  DEALINGS IN THE SOFTWARE.
 +/
/+
 +  Bindings copyright:
 +
 +  Copyright © 2017-2019 Rémi Thebault
 +/
import wayland.client;
import wayland.native.client;
import wayland.native.util;
import wayland.util;

import std.exception : enforce;
import std.string : fromStringz, toStringz;

/++
 +  Move a window during a drag
 +
 +  This protocol enhances normal drag and drop with the ability to move a
 +  window at the same time. This allows having detachable parts of a window
 +  that when dragged out of it become a new window and can be dragged over
 +  an existing window to be reattached.
 +
 +  A typical workflow would be when the user starts dragging on top of a
 +  detachable part of a window, the client would create a wl_data_source and
 +  a xdg_toplevel_drag_v1 object and start the drag as normal via
 +  wl_data_device.start_drag. Once the client determines that the detachable
 +  window contents should be detached from the originating window, it creates
 +  a new xdg_toplevel with these contents and issues a
 +  xdg_toplevel_drag_v1.attach request before mapping it. From now on the new
 +  window is moved by the compositor during the drag as if the client called
 +  xdg_toplevel.move.
 +
 +  Dragging an existing window is similar. The client creates a
 +  xdg_toplevel_drag_v1 object and attaches the existing toplevel before
 +  starting the drag.
 +
 +  Clients use the existing drag and drop mechanism to detect when a window
 +  can be docked or undocked. If the client wants to snap a window into a
 +  parent window it should delete or unmap the dragged top-level. If the
 +  contents should be detached again it attaches a new toplevel as described
 +  above. If a drag operation is cancelled without being dropped, clients
 +  should revert to the previous state, deleting any newly created windows
 +  as appropriate. When a drag operation ends as indicated by
 +  wl_data_source.dnd_drop_performed the dragged toplevel window's final
 +  position is determined as if a xdg_toplevel_move operation ended.
 +
 +  Warning! The protocol described in this file is currently in the testing
 +  phase. Backward compatible changes may be added together with the
 +  corresponding interface version bump. Backward incompatible changes can
 +  only be done by creating a new major version of the extension.
 +/
final class XdgToplevelDragManagerV1 : WlProxy
{
    /// Version of xdg_toplevel_drag_v1.xdg_toplevel_drag_manager_v1
    enum ver = 1;

    /// Build a XdgToplevelDragManagerV1 from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates XdgToplevelDragManagerV1 objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return xdgToplevelDragManagerV1Iface;
    }

    /// Op-code of XdgToplevelDragManagerV1.destroy.
    enum destroyOpCode = 0;
    /// Op-code of XdgToplevelDragManagerV1.getXdgToplevelDrag.
    enum getXdgToplevelDragOpCode = 1;

    /// Version of xdg_toplevel_drag_v1 protocol introducing XdgToplevelDragManagerV1.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_toplevel_drag_v1 protocol introducing XdgToplevelDragManagerV1.getXdgToplevelDrag.
    enum getXdgToplevelDragSinceVersion = 1;

    enum Error : uint
    {
        /// data_source already used for toplevel drag
        invalidSource = 0,
    }

    /++
     +  destroy the xdg_toplevel_drag_manager_v1 object
     +
     +  Destroy this xdg_toplevel_drag_manager_v1 object. Other objects,
     +  including xdg_toplevel_drag_v1 objects created by this factory, are not
     +  affected by this request.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  get an xdg_toplevel_drag for a wl_data_source
     +
     +  Create an xdg_toplevel_drag for a drag and drop operation that is going
     +  to be started with data_source.
     +
     +  This request can only be made on sources used in drag-and-drop, so it
     +  must be performed before wl_data_device.start_drag. Attempting to use
     +  the source other than for drag-and-drop such as in
     +  wl_data_device.set_selection will raise an invalid_source error.
     +
     +  Destroying data_source while a toplevel is attached to the
     +  xdg_toplevel_drag is undefined.
     +/
    XdgToplevelDragV1 getXdgToplevelDrag(WlDataSource dataSource)
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getXdgToplevelDragOpCode, XdgToplevelDragV1.iface.native, null,
            dataSource.proxy
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(XdgToplevelDragV1)_p;
        return new XdgToplevelDragV1(_pp);
    }
}

/// Object representing a toplevel move during a drag
final class XdgToplevelDragV1 : WlProxy
{
    /// Version of xdg_toplevel_drag_v1.xdg_toplevel_drag_v1
    enum ver = 1;

    /// Build a XdgToplevelDragV1 from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates XdgToplevelDragV1 objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return xdgToplevelDragV1Iface;
    }

    /// Op-code of XdgToplevelDragV1.destroy.
    enum destroyOpCode = 0;
    /// Op-code of XdgToplevelDragV1.attach.
    enum attachOpCode = 1;

    /// Version of xdg_toplevel_drag_v1 protocol introducing XdgToplevelDragV1.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_toplevel_drag_v1 protocol introducing XdgToplevelDragV1.attach.
    enum attachSinceVersion = 1;

    enum Error : uint
    {
        /// valid toplevel already attached
        toplevelAttached = 0,
        /// drag has not ended
        ongoingDrag = 1,
    }

    /++
     +  destroy an xdg_toplevel_drag_v1 object
     +
     +  Destroy this xdg_toplevel_drag_v1 object. This request must only be
     +  called after the underlying wl_data_source drag has ended, as indicated
     +  by the dnd_drop_performed or cancelled events. In any other case an
     +  ongoing_drag error is raised.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  Move a toplevel with the drag operation
     +
     +  Request that the window will be moved with the cursor during the drag
     +  operation. The offset is a hint to the compositor how the toplevel
     +  should be positioned relative to the cursor hotspot in surface local
     +  coordinates and relative to the geometry of the toplevel being attached.
     +  See xdg_surface.set_window_geometry. For example it might only
     +  be used when an unmapped window is attached. The attached window
     +  does not participate in the selection of the drag target.
     +
     +  If the toplevel is unmapped while it is attached, it is automatically
     +  detached from the drag. In this case this request has to be called again
     +  if the window should be attached after it is remapped.
     +
     +  This request can be called multiple times but issuing it while a
     +  toplevel with an active role is attached raises a toplevel_attached
     +  error.
     +/
    void attach(XdgToplevel toplevel,
                int xOffset,
                int yOffset)
    {
        wl_proxy_marshal(
            proxy, attachOpCode, toplevel.proxy, xOffset, yOffset
        );
    }
}

private:

immutable WlProxyInterface xdgToplevelDragManagerV1Iface;
immutable WlProxyInterface xdgToplevelDragV1Iface;

immutable final class XdgToplevelDragManagerV1Iface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new XdgToplevelDragManagerV1(proxy);
    }
}

immutable final class XdgToplevelDragV1Iface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new XdgToplevelDragV1(proxy);
    }
}

immutable wl_interface[] wl_ifaces;

enum xdgToplevelDragManagerV1Index = 0;
enum xdgToplevelDragV1Index = 1;

shared static this()
{
    auto ifaces = new wl_interface[2];

    auto msgTypes = [
        &ifaces[xdgToplevelDragV1Index],
        cast(wl_interface*)WlDataSource.iface.native,
        cast(wl_interface*)XdgToplevel.iface.native,
        null,
        null,
    ];

    auto xdg_toplevel_drag_manager_v1_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("get_xdg_toplevel_drag", "no", &msgTypes[0]),
    ];
    ifaces[xdgToplevelDragManagerV1Index].name = "xdg_toplevel_drag_manager_v1";
    ifaces[xdgToplevelDragManagerV1Index].version_ = 1;
    ifaces[xdgToplevelDragManagerV1Index].method_count = 2;
    ifaces[xdgToplevelDragManagerV1Index].methods = xdg_toplevel_drag_manager_v1_requests.ptr;

    auto xdg_toplevel_drag_v1_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("attach", "oii", &msgTypes[2]),
    ];
    ifaces[xdgToplevelDragV1Index].name = "xdg_toplevel_drag_v1";
    ifaces[xdgToplevelDragV1Index].version_ = 1;
    ifaces[xdgToplevelDragV1Index].method_count = 2;
    ifaces[xdgToplevelDragV1Index].methods = xdg_toplevel_drag_v1_requests.ptr;

    import std.exception : assumeUnique;
    wl_ifaces = assumeUnique(ifaces);

    xdgToplevelDragManagerV1Iface = new immutable XdgToplevelDragManagerV1Iface( &wl_ifaces[xdgToplevelDragManagerV1Index] );
    xdgToplevelDragV1Iface = new immutable XdgToplevelDragV1Iface( &wl_ifaces[xdgToplevelDragV1Index] );
}

extern(C) nothrow
{

}
