/++
 +  Module generated by wayland:scanner-v0.3.1 for xdg_activation_v1 protocol
 +    xml protocol:   xdg-activation-v1.xml
 +    generated code: client
 +/
module xdgactivation;
/+
 +  Protocol copyright:
 +
 +  Copyright © 2020 Aleix Pol Gonzalez <aleixpol@kde.org>
 +  Copyright © 2020 Carlos Garnacho <carlosg@gnome.org>
 +
 +  Permission is hereby granted, free of charge, to any person obtaining a
 +  copy of this software and associated documentation files (the "Software"),
 +  to deal in the Software without restriction, including without limitation
 +  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 +  and/or sell copies of the Software, and to permit persons to whom the
 +  Software is furnished to do so, subject to the following conditions:
 +
 +  The above copyright notice and this permission notice (including the next
 +  paragraph) shall be included in all copies or substantial portions of the
 +  Software.
 +
 +  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 +  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 +  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 +  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 +  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 +  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 +  DEALINGS IN THE SOFTWARE.
 +/
/+
 +  Bindings copyright:
 +
 +  Copyright © 2017-2019 Rémi Thebault
 +/
import wayland.client;
import wayland.native.client;
import wayland.native.util;
import wayland.util;

import std.exception : enforce;
import std.string : fromStringz, toStringz;

/++
 +  interface for activating surfaces
 +
 +  A global interface used for informing the compositor about applications
 +  being activated or started, or for applications to request to be
 +  activated.
 +/
final class XdgActivationV1 : WlProxy
{
    /// Version of xdg_activation_v1.xdg_activation_v1
    enum ver = 1;

    /// Build a XdgActivationV1 from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates XdgActivationV1 objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return xdgActivationV1Iface;
    }

    /// Op-code of XdgActivationV1.destroy.
    enum destroyOpCode = 0;
    /// Op-code of XdgActivationV1.getActivationToken.
    enum getActivationTokenOpCode = 1;
    /// Op-code of XdgActivationV1.activate.
    enum activateOpCode = 2;

    /// Version of xdg_activation_v1 protocol introducing XdgActivationV1.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_activation_v1 protocol introducing XdgActivationV1.getActivationToken.
    enum getActivationTokenSinceVersion = 1;
    /// Version of xdg_activation_v1 protocol introducing XdgActivationV1.activate.
    enum activateSinceVersion = 1;

    /++
     +  destroy the xdg_activation object
     +
     +  Notify the compositor that the xdg_activation object will no longer be
     +  used.
     +
     +  The child objects created via this interface are unaffected and should
     +  be destroyed separately.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  requests a token
     +
     +  Creates an xdg_activation_token_v1 object that will provide
     +  the initiating client with a unique token for this activation. This
     +  token should be offered to the clients to be activated.
     +/
    XdgActivationTokenV1 getActivationToken()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getActivationTokenOpCode, XdgActivationTokenV1.iface.native,
            null
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(XdgActivationTokenV1)_p;
        return new XdgActivationTokenV1(_pp);
    }

    /++
     +  notify new interaction being available
     +
     +  Requests surface activation. It's up to the compositor to display
     +  this information as desired, for example by placing the surface above
     +  the rest.
     +
     +  The compositor may know who requested this by checking the activation
     +  token and might decide not to follow through with the activation if it's
     +  considered unwanted.
     +
     +  Compositors can ignore unknown activation tokens when an invalid
     +  token is passed.
     +/
    void activate(string token,
                  WlSurface surface)
    {
        wl_proxy_marshal(
            proxy, activateOpCode, toStringz(token), surface.proxy
        );
    }
}

/++
 +  an exported activation handle
 +
 +  An object for setting up a token and receiving a token handle that can
 +  be passed as an activation token to another client.
 +
 +  The object is created using the xdg_activation_v1.get_activation_token
 +  request. This object should then be populated with the app_id, surface
 +  and serial information and committed. The compositor shall then issue a
 +  done event with the token. In case the request's parameters are invalid,
 +  the compositor will provide an invalid token.
 +/
final class XdgActivationTokenV1 : WlProxy
{
    /// Version of xdg_activation_v1.xdg_activation_token_v1
    enum ver = 1;

    /// Build a XdgActivationTokenV1 from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_xdg_activation_token_v1_listener, cast(void*) this);
    }

    /// Interface object that creates XdgActivationTokenV1 objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return xdgActivationTokenV1Iface;
    }

    /// Op-code of XdgActivationTokenV1.setSerial.
    enum setSerialOpCode = 0;
    /// Op-code of XdgActivationTokenV1.setAppId.
    enum setAppIdOpCode = 1;
    /// Op-code of XdgActivationTokenV1.setSurface.
    enum setSurfaceOpCode = 2;
    /// Op-code of XdgActivationTokenV1.commit.
    enum commitOpCode = 3;
    /// Op-code of XdgActivationTokenV1.destroy.
    enum destroyOpCode = 4;

    /// Version of xdg_activation_v1 protocol introducing XdgActivationTokenV1.setSerial.
    enum setSerialSinceVersion = 1;
    /// Version of xdg_activation_v1 protocol introducing XdgActivationTokenV1.setAppId.
    enum setAppIdSinceVersion = 1;
    /// Version of xdg_activation_v1 protocol introducing XdgActivationTokenV1.setSurface.
    enum setSurfaceSinceVersion = 1;
    /// Version of xdg_activation_v1 protocol introducing XdgActivationTokenV1.commit.
    enum commitSinceVersion = 1;
    /// Version of xdg_activation_v1 protocol introducing XdgActivationTokenV1.destroy.
    enum destroySinceVersion = 1;

    /// xdg_activation_v1 protocol version introducing XdgActivationTokenV1.onDone.
    enum onDoneSinceVersion = 1;

    /// Event delegate signature of XdgActivationTokenV1.onDone.
    alias OnDoneEventDg = void delegate(XdgActivationTokenV1 xdgActivationTokenV1,
                                        string token);

    enum Error : uint
    {
        /// The token has already been used previously
        alreadyUsed = 0,
    }

    /++
     +  specifies the seat and serial of the activating event
     +
     +  Provides information about the seat and serial event that requested the
     +  token.
     +
     +  The serial can come from an input or focus event. For instance, if a
     +  click triggers the launch of a third-party client, the launcher client
     +  should send a set_serial request with the serial and seat from the
     +  wl_pointer.button event.
     +
     +  Some compositors might refuse to activate toplevels when the token
     +  doesn't have a valid and recent enough event serial.
     +
     +  Must be sent before commit. This information is optional.
     +/
    void setSerial(uint serial,
                   WlSeat seat)
    {
        wl_proxy_marshal(
            proxy, setSerialOpCode, serial, seat.proxy
        );
    }

    /++
     +  specifies the application being activated
     +
     +  The requesting client can specify an app_id to associate the token
     +  being created with it.
     +
     +  Must be sent before commit. This information is optional.
     +/
    void setAppId(string appId)
    {
        wl_proxy_marshal(
            proxy, setAppIdOpCode, toStringz(appId)
        );
    }

    /++
     +  specifies the surface requesting activation
     +
     +  This request sets the surface requesting the activation. Note, this is
     +  different from the surface that will be activated.
     +
     +  Some compositors might refuse to activate toplevels when the token
     +  doesn't have a requesting surface.
     +
     +  Must be sent before commit. This information is optional.
     +/
    void setSurface(WlSurface surface)
    {
        wl_proxy_marshal(
            proxy, setSurfaceOpCode, surface.proxy
        );
    }

    /++
     +  issues the token request
     +
     +  Requests an activation token based on the different parameters that
     +  have been offered through set_serial, set_surface and set_app_id.
     +/
    void commit()
    {
        wl_proxy_marshal(
            proxy, commitOpCode
        );
    }

    /++
     +  destroy the xdg_activation_token_v1 object
     +
     +  Notify the compositor that the xdg_activation_token_v1 object will no
     +  longer be used. The received token stays valid.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  the exported activation token
     +
     +  The 'done' event contains the unique token of this activation request
     +  and notifies that the provider is done.
     +/
    @property void onDone(OnDoneEventDg dg)
    {
        _onDone = dg;
    }

    private OnDoneEventDg _onDone;
}

private:

immutable WlProxyInterface xdgActivationV1Iface;
immutable WlProxyInterface xdgActivationTokenV1Iface;

immutable final class XdgActivationV1Iface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new XdgActivationV1(proxy);
    }
}

immutable final class XdgActivationTokenV1Iface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new XdgActivationTokenV1(proxy);
    }
}

immutable wl_interface[] wl_ifaces;

enum xdgActivationV1Index = 0;
enum xdgActivationTokenV1Index = 1;

shared static this()
{
    auto ifaces = new wl_interface[2];

    auto msgTypes = [
        null,
        &ifaces[xdgActivationTokenV1Index],
        null,
        cast(wl_interface*)WlSurface.iface.native,
        null,
        cast(wl_interface*)WlSeat.iface.native,
        cast(wl_interface*)WlSurface.iface.native,
    ];

    auto xdg_activation_v1_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("get_activation_token", "n", &msgTypes[1]),
        wl_message("activate", "so", &msgTypes[2]),
    ];
    ifaces[xdgActivationV1Index].name = "xdg_activation_v1";
    ifaces[xdgActivationV1Index].version_ = 1;
    ifaces[xdgActivationV1Index].method_count = 3;
    ifaces[xdgActivationV1Index].methods = xdg_activation_v1_requests.ptr;

    auto xdg_activation_token_v1_requests = [
        wl_message("set_serial", "uo", &msgTypes[4]),
        wl_message("set_app_id", "s", &msgTypes[0]),
        wl_message("set_surface", "o", &msgTypes[6]),
        wl_message("commit", "", &msgTypes[0]),
        wl_message("destroy", "", &msgTypes[0]),
    ];
    auto xdg_activation_token_v1_events = [
        wl_message("done", "s", &msgTypes[0]),
    ];
    ifaces[xdgActivationTokenV1Index].name = "xdg_activation_token_v1";
    ifaces[xdgActivationTokenV1Index].version_ = 1;
    ifaces[xdgActivationTokenV1Index].method_count = 5;
    ifaces[xdgActivationTokenV1Index].methods = xdg_activation_token_v1_requests.ptr;
    ifaces[xdgActivationTokenV1Index].event_count = 1;
    ifaces[xdgActivationTokenV1Index].events = xdg_activation_token_v1_events.ptr;

    import std.exception : assumeUnique;
    wl_ifaces = assumeUnique(ifaces);

    xdgActivationV1Iface = new immutable XdgActivationV1Iface( &wl_ifaces[xdgActivationV1Index] );
    xdgActivationTokenV1Iface = new immutable XdgActivationTokenV1Iface( &wl_ifaces[xdgActivationTokenV1Index] );
}

extern(C) nothrow
{

    struct xdg_activation_token_v1_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      const(char)* token) done;
    }

    __gshared wl_d_xdg_activation_token_v1_listener = xdg_activation_token_v1_listener (&wl_d_on_xdg_activation_token_v1_done);

    void wl_d_on_xdg_activation_token_v1_done(void* data,
                                              wl_proxy* proxy,
                                              const(char)* token)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(XdgActivationTokenV1)_p;
            assert(_i, "listener stub proxy is not XdgActivationTokenV1");
            if (_i._onDone)
            {
                _i._onDone(_i, fromStringz(token).idup);
            }
        });
    }
}
