/++
 +  Module generated by wayland:scanner-v0.3.1 for xdg_toplevel_icon_v1 protocol
 +    xml protocol:   xdg-toplevel-icon-v1.xml
 +    generated code: client
 +/
module xdgtoplevelicon;
/+
 +  Protocol copyright:
 +
 +  Copyright © 2023-2024 Matthias Klumpp
 +  Copyright ©      2024 David Edmundson
 +
 +  Permission is hereby granted, free of charge, to any person obtaining a
 +  copy of this software and associated documentation files (the "Software"),
 +  to deal in the Software without restriction, including without limitation
 +  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 +  and/or sell copies of the Software, and to permit persons to whom the
 +  Software is furnished to do so, subject to the following conditions:
 +
 +  The above copyright notice and this permission notice (including the next
 +  paragraph) shall be included in all copies or substantial portions of the
 +  Software.
 +
 +  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 +  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 +  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 +  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 +  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 +  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 +  DEALINGS IN THE SOFTWARE.
 +/
/+
 +  Bindings copyright:
 +
 +  Copyright © 2017-2019 Rémi Thebault
 +/
import wayland.client;
import wayland.native.client;
import wayland.native.util;
import wayland.util;

import xdgshell;

import std.exception : enforce;
import std.string : fromStringz, toStringz;

/++
 +  interface to manage toplevel icons
 +
 +  This interface allows clients to create toplevel window icons and set
 +  them on toplevel windows to be displayed to the user.
 +/
final class XdgToplevelIconManagerV1 : WlProxy
{
    /// Version of xdg_toplevel_icon_v1.xdg_toplevel_icon_manager_v1
    enum ver = 1;

    /// Build a XdgToplevelIconManagerV1 from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_xdg_toplevel_icon_manager_v1_listener, cast(void*) this);
    }

    /// Interface object that creates XdgToplevelIconManagerV1 objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return xdgToplevelIconManagerV1Iface;
    }

    /// Op-code of XdgToplevelIconManagerV1.destroy.
    enum destroyOpCode = 0;
    /// Op-code of XdgToplevelIconManagerV1.createIcon.
    enum createIconOpCode = 1;
    /// Op-code of XdgToplevelIconManagerV1.setIcon.
    enum setIconOpCode = 2;

    /// Version of xdg_toplevel_icon_v1 protocol introducing XdgToplevelIconManagerV1.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_toplevel_icon_v1 protocol introducing XdgToplevelIconManagerV1.createIcon.
    enum createIconSinceVersion = 1;
    /// Version of xdg_toplevel_icon_v1 protocol introducing XdgToplevelIconManagerV1.setIcon.
    enum setIconSinceVersion = 1;

    /// xdg_toplevel_icon_v1 protocol version introducing XdgToplevelIconManagerV1.onIconSize.
    enum onIconSizeSinceVersion = 1;
    /// xdg_toplevel_icon_v1 protocol version introducing XdgToplevelIconManagerV1.onDone.
    enum onDoneSinceVersion = 1;

    /// Event delegate signature of XdgToplevelIconManagerV1.onIconSize.
    alias OnIconSizeEventDg = void delegate(XdgToplevelIconManagerV1 xdgToplevelIconManagerV1,
                                            int size);
    /// Event delegate signature of XdgToplevelIconManagerV1.onDone.
    alias OnDoneEventDg = void delegate(XdgToplevelIconManagerV1 xdgToplevelIconManagerV1);

    /++
     +  destroy the toplevel icon manager
     +
     +  Destroy the toplevel icon manager.
     +  This does not destroy objects created with the manager.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  create a new icon instance
     +
     +  Creates a new icon object. This icon can then be attached to a
     +  xdg_toplevel via the 'set_icon' request.
     +/
    XdgToplevelIconV1 createIcon()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, createIconOpCode, XdgToplevelIconV1.iface.native, null
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(XdgToplevelIconV1)_p;
        return new XdgToplevelIconV1(_pp);
    }

    /++
     +  set an icon on a toplevel window
     +
     +  This request assigns the icon 'icon' to 'toplevel', or clears the
     +  toplevel icon if 'icon' was null.
     +  This state is double-buffered and is applied on the next
     +  wl_surface.commit of the toplevel.
     +
     +  After making this call, the xdg_toplevel_icon_v1 provided as 'icon'
     +  can be destroyed by the client without 'toplevel' losing its icon.
     +  The xdg_toplevel_icon_v1 is immutable from this point, and any
     +  future attempts to change it must raise the
     +  'xdg_toplevel_icon_v1.immutable' protocol error.
     +
     +  The compositor must set the toplevel icon from either the pixel data
     +  the icon provides, or by loading a stock icon using the icon name.
     +  See the description of 'xdg_toplevel_icon_v1' for details.
     +
     +  If 'icon' is set to null, the icon of the respective toplevel is reset
     +  to its default icon $(LPAREN)usually the icon of the application, derived from
     +  its desktop-entry file, or a placeholder icon$(RPAREN).
     +  If this request is passed an icon with no pixel buffers or icon name
     +  assigned, the icon must be reset just like if 'icon' was null.
     +/
    void setIcon(XdgToplevel toplevel,
                 XdgToplevelIconV1 icon)
    {
        wl_proxy_marshal(
            proxy, setIconOpCode, toplevel.proxy,
            icon is null ? null : icon.proxy
        );
    }

    /++
     +  describes a supported &amp; preferred icon size
     +
     +  This event indicates an icon size the compositor prefers to be
     +  available if the client has scalable icons and can render to any size.
     +
     +  When the 'xdg_toplevel_icon_manager_v1' object is created, the
     +  compositor may send one or more 'icon_size' events to describe the list
     +  of preferred icon sizes. If the compositor has no size preference, it
     +  may not send any 'icon_size' event, and it is up to the client to
     +  decide a suitable icon size.
     +
     +  A sequence of 'icon_size' events must be finished with a 'done' event.
     +  If the compositor has no size preferences, it must still send the
     +  'done' event, without any preceding 'icon_size' events.
     +/
    @property void onIconSize(OnIconSizeEventDg dg)
    {
        _onIconSize = dg;
    }

    /++
     +  all information has been sent
     +
     +  This event is sent after all 'icon_size' events have been sent.
     +/
    @property void onDone(OnDoneEventDg dg)
    {
        _onDone = dg;
    }

    private OnIconSizeEventDg _onIconSize;
    private OnDoneEventDg _onDone;
}

/++
 +  a toplevel window icon
 +
 +  This interface defines a toplevel icon.
 +  An icon can have a name, and multiple buffers.
 +  In order to be applied, the icon must have either a name, or at least
 +  one buffer assigned. Applying an empty icon $(LPAREN)with no buffer or name$(RPAREN) to
 +  a toplevel should reset its icon to the default icon.
 +
 +  It is up to compositor policy whether to prefer using a buffer or loading
 +  an icon via its name. See 'set_name' and 'add_buffer' for details.
 +/
final class XdgToplevelIconV1 : WlProxy
{
    /// Version of xdg_toplevel_icon_v1.xdg_toplevel_icon_v1
    enum ver = 1;

    /// Build a XdgToplevelIconV1 from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates XdgToplevelIconV1 objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return xdgToplevelIconV1Iface;
    }

    /// Op-code of XdgToplevelIconV1.destroy.
    enum destroyOpCode = 0;
    /// Op-code of XdgToplevelIconV1.setName.
    enum setNameOpCode = 1;
    /// Op-code of XdgToplevelIconV1.addBuffer.
    enum addBufferOpCode = 2;

    /// Version of xdg_toplevel_icon_v1 protocol introducing XdgToplevelIconV1.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_toplevel_icon_v1 protocol introducing XdgToplevelIconV1.setName.
    enum setNameSinceVersion = 1;
    /// Version of xdg_toplevel_icon_v1 protocol introducing XdgToplevelIconV1.addBuffer.
    enum addBufferSinceVersion = 1;

    enum Error : uint
    {
        /// the provided buffer does not satisfy requirements
        invalidBuffer = 1,
        /// the icon has already been assigned to a toplevel and must not be changed
        immutable_ = 2,
        /// the provided buffer has been destroyed before the toplevel icon
        noBuffer = 3,
    }

    /++
     +  destroy the icon object
     +
     +  Destroys the 'xdg_toplevel_icon_v1' object.
     +  The icon must still remain set on every toplevel it was assigned to,
     +  until the toplevel icon is reset explicitly.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  set an icon name
     +
     +  This request assigns an icon name to this icon.
     +  Any previously set name is overridden.
     +
     +  The compositor must resolve 'icon_name' according to the lookup rules
     +  described in the XDG icon theme specification[1] using the
     +  environment's current icon theme.
     +
     +  If the compositor does not support icon names or cannot resolve
     +  'icon_name' according to the XDG icon theme specification it must
     +  fall back to using pixel buffer data instead.
     +
     +  If this request is made after the icon has been assigned to a toplevel
     +  via 'set_icon', a 'immutable' error must be raised.
     +
     +  [1]: https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
     +/
    void setName(string iconName)
    {
        wl_proxy_marshal(
            proxy, setNameOpCode, toStringz(iconName)
        );
    }

    /++
     +  add icon data from a pixel buffer
     +
     +  This request adds pixel data supplied as wl_buffer to the icon.
     +
     +  The client should add pixel data for all icon sizes and scales that
     +  it can provide, or which are explicitly requested by the compositor
     +  via 'icon_size' events on xdg_toplevel_icon_manager_v1.
     +
     +  The wl_buffer supplying pixel data as 'buffer' must be backed by wl_shm
     +  and must be a square $(LPAREN)width and height being equal$(RPAREN).
     +  If any of these buffer requirements are not fulfilled, a 'invalid_buffer'
     +  error must be raised.
     +
     +  If this icon instance already has a buffer of the same size and scale
     +  from a previous 'add_buffer' request, data from the last request
     +  overrides the preexisting pixel data.
     +
     +  The wl_buffer must be kept alive for as long as the xdg_toplevel_icon
     +  it is associated with is not destroyed, otherwise a 'no_buffer' error
     +  is raised. The buffer contents must not be modified after it was
     +  assigned to the icon. As a result, the region of the wl_shm_pool's
     +  backing storage used for the wl_buffer must not be modified after this
     +  request is sent. The wl_buffer.release event is unused.
     +
     +  If this request is made after the icon has been assigned to a toplevel
     +  via 'set_icon', a 'immutable' error must be raised.
     +/
    void addBuffer(WlBuffer buffer,
                   int scale)
    {
        wl_proxy_marshal(
            proxy, addBufferOpCode, buffer.proxy, scale
        );
    }
}

private:

immutable WlProxyInterface xdgToplevelIconManagerV1Iface;
immutable WlProxyInterface xdgToplevelIconV1Iface;

immutable final class XdgToplevelIconManagerV1Iface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new XdgToplevelIconManagerV1(proxy);
    }
}

immutable final class XdgToplevelIconV1Iface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new XdgToplevelIconV1(proxy);
    }
}

immutable wl_interface[] wl_ifaces;

enum xdgToplevelIconManagerV1Index = 0;
enum xdgToplevelIconV1Index = 1;

shared static this()
{
    auto ifaces = new wl_interface[2];

    auto msgTypes = [
        null,
        &ifaces[xdgToplevelIconV1Index],
        cast(wl_interface*)XdgToplevel.iface.native,
        &ifaces[xdgToplevelIconV1Index],
        cast(wl_interface*)WlBuffer.iface.native,
        null,
    ];

    auto xdg_toplevel_icon_manager_v1_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("create_icon", "n", &msgTypes[1]),
        wl_message("set_icon", "o?o", &msgTypes[2]),
    ];
    auto xdg_toplevel_icon_manager_v1_events = [
        wl_message("icon_size", "i", &msgTypes[0]),
        wl_message("done", "", &msgTypes[0]),
    ];
    ifaces[xdgToplevelIconManagerV1Index].name = "xdg_toplevel_icon_manager_v1";
    ifaces[xdgToplevelIconManagerV1Index].version_ = 1;
    ifaces[xdgToplevelIconManagerV1Index].method_count = 3;
    ifaces[xdgToplevelIconManagerV1Index].methods = xdg_toplevel_icon_manager_v1_requests.ptr;
    ifaces[xdgToplevelIconManagerV1Index].event_count = 2;
    ifaces[xdgToplevelIconManagerV1Index].events = xdg_toplevel_icon_manager_v1_events.ptr;

    auto xdg_toplevel_icon_v1_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("set_name", "s", &msgTypes[0]),
        wl_message("add_buffer", "oi", &msgTypes[4]),
    ];
    ifaces[xdgToplevelIconV1Index].name = "xdg_toplevel_icon_v1";
    ifaces[xdgToplevelIconV1Index].version_ = 1;
    ifaces[xdgToplevelIconV1Index].method_count = 3;
    ifaces[xdgToplevelIconV1Index].methods = xdg_toplevel_icon_v1_requests.ptr;

    import std.exception : assumeUnique;
    wl_ifaces = assumeUnique(ifaces);

    xdgToplevelIconManagerV1Iface = new immutable XdgToplevelIconManagerV1Iface( &wl_ifaces[xdgToplevelIconManagerV1Index] );
    xdgToplevelIconV1Iface = new immutable XdgToplevelIconV1Iface( &wl_ifaces[xdgToplevelIconV1Index] );
}

extern(C) nothrow
{
    struct xdg_toplevel_icon_manager_v1_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      int size) icon_size;
        void function(void* data,
                      wl_proxy* proxy) done;
    }

    __gshared wl_d_xdg_toplevel_icon_manager_v1_listener = xdg_toplevel_icon_manager_v1_listener (&wl_d_on_xdg_toplevel_icon_manager_v1_icon_size,
                                                                                                  &wl_d_on_xdg_toplevel_icon_manager_v1_done);

    void wl_d_on_xdg_toplevel_icon_manager_v1_icon_size(void* data,
                                                        wl_proxy* proxy,
                                                        int size)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(XdgToplevelIconManagerV1)_p;
            assert(_i, "listener stub proxy is not XdgToplevelIconManagerV1");
            if (_i._onIconSize)
            {
                _i._onIconSize(_i, size);
            }
        });
    }

    void wl_d_on_xdg_toplevel_icon_manager_v1_done(void* data,
                                                   wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(XdgToplevelIconManagerV1)_p;
            assert(_i, "listener stub proxy is not XdgToplevelIconManagerV1");
            if (_i._onDone)
            {
                _i._onDone(_i);
            }
        });
    }

}
