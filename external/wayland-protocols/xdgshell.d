/++
 +  Module generated by wayland:scanner-v0.3.1 for xdg_shell protocol
 +    xml protocol:   xdg-shell.xml
 +    generated code: client
 +/
module xdgshell;
/+
 +  Protocol copyright:
 +
 +  Copyright © 2008-2013 Kristian Høgsberg
 +  Copyright © 2013      Rafael Antognolli
 +  Copyright © 2013      Jasper St. Pierre
 +  Copyright © 2010-2013 Intel Corporation
 +  Copyright © 2015-2017 Samsung Electronics Co., Ltd
 +  Copyright © 2015-2017 Red Hat Inc.
 +
 +  Permission is hereby granted, free of charge, to any person obtaining a
 +  copy of this software and associated documentation files (the "Software"),
 +  to deal in the Software without restriction, including without limitation
 +  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 +  and/or sell copies of the Software, and to permit persons to whom the
 +  Software is furnished to do so, subject to the following conditions:
 +
 +  The above copyright notice and this permission notice (including the next
 +  paragraph) shall be included in all copies or substantial portions of the
 +  Software.
 +
 +  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 +  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 +  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 +  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 +  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 +  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 +  DEALINGS IN THE SOFTWARE.
 +/
/+
 +  Bindings copyright:
 +
 +  Copyright © 2017-2019 Rémi Thebault
 +/
import wayland.client;
import wayland.native.client;
import wayland.native.util;
import wayland.util;

import std.exception : enforce;
import std.string : fromStringz, toStringz;

/++
 +  create desktop-style surfaces
 +
 +  The xdg_wm_base interface is exposed as a global object enabling clients
 +  to turn their wl_surfaces into windows in a desktop environment. It
 +  defines the basic functionality needed for clients and the compositor to
 +  create windows that can be dragged, resized, maximized, etc, as well as
 +  creating transient windows such as popup menus.
 +/
final class XdgWmBase : WlProxy
{
    /// Version of xdg_shell.xdg_wm_base
    enum ver = 6;

    /// Build a XdgWmBase from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_xdg_wm_base_listener, cast(void*) this);
    }

    /// Interface object that creates XdgWmBase objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return xdgWmBaseIface;
    }

    /// Op-code of XdgWmBase.destroy.
    enum destroyOpCode = 0;
    /// Op-code of XdgWmBase.createPositioner.
    enum createPositionerOpCode = 1;
    /// Op-code of XdgWmBase.getXdgSurface.
    enum getXdgSurfaceOpCode = 2;
    /// Op-code of XdgWmBase.pong.
    enum pongOpCode = 3;

    /// Version of xdg_shell protocol introducing XdgWmBase.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgWmBase.createPositioner.
    enum createPositionerSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgWmBase.getXdgSurface.
    enum getXdgSurfaceSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgWmBase.pong.
    enum pongSinceVersion = 1;

    /// xdg_shell protocol version introducing XdgWmBase.onPing.
    enum onPingSinceVersion = 1;

    /// Event delegate signature of XdgWmBase.onPing.
    alias OnPingEventDg = void delegate(XdgWmBase xdgWmBase,
                                        uint serial);

    enum Error : uint
    {
        /// given wl_surface has another role
        role = 0,
        /// xdg_wm_base was destroyed before children
        defunctSurfaces = 1,
        /// the client tried to map or destroy a non-topmost popup
        notTheTopmostPopup = 2,
        /// the client specified an invalid popup parent surface
        invalidPopupParent = 3,
        /// the client provided an invalid surface state
        invalidSurfaceState = 4,
        /// the client provided an invalid positioner
        invalidPositioner = 5,
        /// the client didn’t respond to a ping event in time
        unresponsive = 6,
    }

    /++
     +  destroy xdg_wm_base
     +
     +  Destroy this xdg_wm_base object.
     +
     +  Destroying a bound xdg_wm_base object while there are surfaces
     +  still alive created by this xdg_wm_base object instance is illegal
     +  and will result in a defunct_surfaces error.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  create a positioner object
     +
     +  Create a positioner object. A positioner object is used to position
     +  surfaces relative to some parent surface. See the interface description
     +  and xdg_surface.get_popup for details.
     +/
    XdgPositioner createPositioner()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, createPositionerOpCode, XdgPositioner.iface.native, null
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(XdgPositioner)_p;
        return new XdgPositioner(_pp);
    }

    /++
     +  create a shell surface from a surface
     +
     +  This creates an xdg_surface for the given surface. While xdg_surface
     +  itself is not a role, the corresponding surface may only be assigned
     +  a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is
     +  illegal to create an xdg_surface for a wl_surface which already has an
     +  assigned role and this will result in a role error.
     +
     +  This creates an xdg_surface for the given surface. An xdg_surface is
     +  used as basis to define a role to a given surface, such as xdg_toplevel
     +  or xdg_popup. It also manages functionality shared between xdg_surface
     +  based surface roles.
     +
     +  See the documentation of xdg_surface for more details about what an
     +  xdg_surface is and how it is used.
     +/
    XdgSurface getXdgSurface(WlSurface surface)
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getXdgSurfaceOpCode, XdgSurface.iface.native, null,
            surface.proxy
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(XdgSurface)_p;
        return new XdgSurface(_pp);
    }

    /++
     +  respond to a ping event
     +
     +  A client must respond to a ping event with a pong request or
     +  the client may be deemed unresponsive. See xdg_wm_base.ping
     +  and xdg_wm_base.error.unresponsive.
     +/
    void pong(uint serial)
    {
        wl_proxy_marshal(
            proxy, pongOpCode, serial
        );
    }

    /++
     +  check if the client is alive
     +
     +  The ping event asks the client if it's still alive. Pass the
     +  serial specified in the event back to the compositor by sending
     +  a "pong" request back with the specified serial. See xdg_wm_base.pong.
     +
     +  Compositors can use this to determine if the client is still
     +  alive. It's unspecified what will happen if the client doesn't
     +  respond to the ping request, or in what timeframe. Clients should
     +  try to respond in a reasonable amount of time. The “unresponsive”
     +  error is provided for compositors that wish to disconnect unresponsive
     +  clients.
     +
     +  A compositor is free to ping in any way it wants, but a client must
     +  always respond to any xdg_wm_base object it created.
     +/
    @property void onPing(OnPingEventDg dg)
    {
        _onPing = dg;
    }

    private OnPingEventDg _onPing;
}

/++
 +  child surface positioner
 +
 +  The xdg_positioner provides a collection of rules for the placement of a
 +  child surface relative to a parent surface. Rules can be defined to ensure
 +  the child surface remains within the visible area's borders, and to
 +  specify how the child surface changes its position, such as sliding along
 +  an axis, or flipping around a rectangle. These positioner-created rules are
 +  constrained by the requirement that a child surface must intersect with or
 +  be at least partially adjacent to its parent surface.
 +
 +  See the various requests for details about possible rules.
 +
 +  At the time of the request, the compositor makes a copy of the rules
 +  specified by the xdg_positioner. Thus, after the request is complete the
 +  xdg_positioner object can be destroyed or reused; further changes to the
 +  object will have no effect on previous usages.
 +
 +  For an xdg_positioner object to be considered complete, it must have a
 +  non-zero size set by set_size, and a non-zero anchor rectangle set by
 +  set_anchor_rect. Passing an incomplete xdg_positioner object when
 +  positioning a surface raises an invalid_positioner error.
 +/
final class XdgPositioner : WlProxy
{
    /// Version of xdg_shell.xdg_positioner
    enum ver = 6;

    /// Build a XdgPositioner from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates XdgPositioner objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return xdgPositionerIface;
    }

    /// Op-code of XdgPositioner.destroy.
    enum destroyOpCode = 0;
    /// Op-code of XdgPositioner.setSize.
    enum setSizeOpCode = 1;
    /// Op-code of XdgPositioner.setAnchorRect.
    enum setAnchorRectOpCode = 2;
    /// Op-code of XdgPositioner.setAnchor.
    enum setAnchorOpCode = 3;
    /// Op-code of XdgPositioner.setGravity.
    enum setGravityOpCode = 4;
    /// Op-code of XdgPositioner.setConstraintAdjustment.
    enum setConstraintAdjustmentOpCode = 5;
    /// Op-code of XdgPositioner.setOffset.
    enum setOffsetOpCode = 6;
    /// Op-code of XdgPositioner.setReactive.
    enum setReactiveOpCode = 7;
    /// Op-code of XdgPositioner.setParentSize.
    enum setParentSizeOpCode = 8;
    /// Op-code of XdgPositioner.setParentConfigure.
    enum setParentConfigureOpCode = 9;

    /// Version of xdg_shell protocol introducing XdgPositioner.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgPositioner.setSize.
    enum setSizeSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgPositioner.setAnchorRect.
    enum setAnchorRectSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgPositioner.setAnchor.
    enum setAnchorSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgPositioner.setGravity.
    enum setGravitySinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgPositioner.setConstraintAdjustment.
    enum setConstraintAdjustmentSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgPositioner.setOffset.
    enum setOffsetSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgPositioner.setReactive.
    enum setReactiveSinceVersion = 3;
    /// Version of xdg_shell protocol introducing XdgPositioner.setParentSize.
    enum setParentSizeSinceVersion = 3;
    /// Version of xdg_shell protocol introducing XdgPositioner.setParentConfigure.
    enum setParentConfigureSinceVersion = 3;

    enum Error : uint
    {
        /// invalid input provided
        invalidInput = 0,
    }

    enum Anchor : uint
    {
        none = 0,
        top = 1,
        bottom = 2,
        left = 3,
        right = 4,
        topLeft = 5,
        bottomLeft = 6,
        topRight = 7,
        bottomRight = 8,
    }

    enum Gravity : uint
    {
        none = 0,
        top = 1,
        bottom = 2,
        left = 3,
        right = 4,
        topLeft = 5,
        bottomLeft = 6,
        topRight = 7,
        bottomRight = 8,
    }

    /++
     +  constraint adjustments
     +
     +  The constraint adjustment value define ways the compositor will adjust
     +  the position of the surface, if the unadjusted position would result
     +  in the surface being partly constrained.
     +
     +  Whether a surface is considered 'constrained' is left to the compositor
     +  to determine. For example, the surface may be partly outside the
     +  compositor's defined 'work area', thus necessitating the child surface's
     +  position be adjusted until it is entirely inside the work area.
     +
     +  The adjustments can be combined, according to a defined precedence: 1$(RPAREN)
     +  Flip, 2$(RPAREN) Slide, 3$(RPAREN) Resize.
     +/
    enum ConstraintAdjustment : uint
    {
        none = 0,
        slideX = 1,
        slideY = 2,
        flipX = 4,
        flipY = 8,
        resizeX = 16,
        resizeY = 32,
    }

    /++
     +  destroy the xdg_positioner object
     +
     +  Notify the compositor that the xdg_positioner will no longer be used.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  set the size of the to-be positioned rectangle
     +
     +  Set the size of the surface that is to be positioned with the positioner
     +  object. The size is in surface-local coordinates and corresponds to the
     +  window geometry. See xdg_surface.set_window_geometry.
     +
     +  If a zero or negative size is set the invalid_input error is raised.
     +/
    void setSize(int width,
                 int height)
    {
        wl_proxy_marshal(
            proxy, setSizeOpCode, width, height
        );
    }

    /++
     +  set the anchor rectangle within the parent surface
     +
     +  Specify the anchor rectangle within the parent surface that the child
     +  surface will be placed relative to. The rectangle is relative to the
     +  window geometry as defined by xdg_surface.set_window_geometry of the
     +  parent surface.
     +
     +  When the xdg_positioner object is used to position a child surface, the
     +  anchor rectangle may not extend outside the window geometry of the
     +  positioned child's parent surface.
     +
     +  If a negative size is set the invalid_input error is raised.
     +/
    void setAnchorRect(int x,
                       int y,
                       int width,
                       int height)
    {
        wl_proxy_marshal(
            proxy, setAnchorRectOpCode, x, y, width, height
        );
    }

    /++
     +  set anchor rectangle anchor
     +
     +  Defines the anchor point for the anchor rectangle. The specified anchor
     +  is used derive an anchor point that the child surface will be
     +  positioned relative to. If a corner anchor is set $(LPAREN)e.g. 'top_left' or
     +  'bottom_right'$(RPAREN), the anchor point will be at the specified corner;
     +  otherwise, the derived anchor point will be centered on the specified
     +  edge, or in the center of the anchor rectangle if no edge is specified.
     +/
    void setAnchor(Anchor anchor)
    {
        wl_proxy_marshal(
            proxy, setAnchorOpCode, anchor
        );
    }

    /++
     +  set child surface gravity
     +
     +  Defines in what direction a surface should be positioned, relative to
     +  the anchor point of the parent surface. If a corner gravity is
     +  specified $(LPAREN)e.g. 'bottom_right' or 'top_left'$(RPAREN), then the child surface
     +  will be placed towards the specified gravity; otherwise, the child
     +  surface will be centered over the anchor point on any axis that had no
     +  gravity specified. If the gravity is not in the ‘gravity’ enum, an
     +  invalid_input error is raised.
     +/
    void setGravity(Gravity gravity)
    {
        wl_proxy_marshal(
            proxy, setGravityOpCode, gravity
        );
    }

    /++
     +  set the adjustment to be done when constrained
     +
     +  Specify how the window should be positioned if the originally intended
     +  position caused the surface to be constrained, meaning at least
     +  partially outside positioning boundaries set by the compositor. The
     +  adjustment is set by constructing a bitmask describing the adjustment to
     +  be made when the surface is constrained on that axis.
     +
     +  If no bit for one axis is set, the compositor will assume that the child
     +  surface should not change its position on that axis when constrained.
     +
     +  If more than one bit for one axis is set, the order of how adjustments
     +  are applied is specified in the corresponding adjustment descriptions.
     +
     +  The default adjustment is none.
     +/
    void setConstraintAdjustment(ConstraintAdjustment constraintAdjustment)
    {
        wl_proxy_marshal(
            proxy, setConstraintAdjustmentOpCode, constraintAdjustment
        );
    }

    /++
     +  set surface position offset
     +
     +  Specify the surface position offset relative to the position of the
     +  anchor on the anchor rectangle and the anchor on the surface. For
     +  example if the anchor of the anchor rectangle is at $(LPAREN)x, y$(RPAREN), the surface
     +  has the gravity bottom|right, and the offset is $(LPAREN)ox, oy$(RPAREN), the calculated
     +  surface position will be $(LPAREN)x + ox, y + oy$(RPAREN). The offset position of the
     +  surface is the one used for constraint testing. See
     +  set_constraint_adjustment.
     +
     +  An example use case is placing a popup menu on top of a user interface
     +  element, while aligning the user interface element of the parent surface
     +  with some user interface element placed somewhere in the popup surface.
     +/
    void setOffset(int x,
                   int y)
    {
        wl_proxy_marshal(
            proxy, setOffsetOpCode, x, y
        );
    }

    /++
     +  continuously reconstrain the surface
     +
     +  When set reactive, the surface is reconstrained if the conditions used
     +  for constraining changed, e.g. the parent window moved.
     +
     +  If the conditions changed and the popup was reconstrained, an
     +  xdg_popup.configure event is sent with updated geometry, followed by an
     +  xdg_surface.configure event.
     +/
    void setReactive()
    {
        wl_proxy_marshal(
            proxy, setReactiveOpCode
        );
    }

    /++
     +  Set the parent window geometry the compositor should use when
     +  positioning the popup. The compositor may use this information to
     +  determine the future state the popup should be constrained using. If
     +  this doesn't match the dimension of the parent the popup is eventually
     +  positioned against, the behavior is undefined.
     +
     +  The arguments are given in the surface-local coordinate space.
     +/
    void setParentSize(int parentWidth,
                       int parentHeight)
    {
        wl_proxy_marshal(
            proxy, setParentSizeOpCode, parentWidth, parentHeight
        );
    }

    /++
     +  set parent configure this is a response to
     +
     +  Set the serial of an xdg_surface.configure event this positioner will be
     +  used in response to. The compositor may use this information together
     +  with set_parent_size to determine what future state the popup should be
     +  constrained using.
     +/
    void setParentConfigure(uint serial)
    {
        wl_proxy_marshal(
            proxy, setParentConfigureOpCode, serial
        );
    }
}

/++
 +  desktop user interface surface base interface
 +
 +  An interface that may be implemented by a wl_surface, for
 +  implementations that provide a desktop-style user interface.
 +
 +  It provides a base set of functionality required to construct user
 +  interface elements requiring management by the compositor, such as
 +  toplevel windows, menus, etc. The types of functionality are split into
 +  xdg_surface roles.
 +
 +  Creating an xdg_surface does not set the role for a wl_surface. In order
 +  to map an xdg_surface, the client must create a role-specific object
 +  using, e.g., get_toplevel, get_popup. The wl_surface for any given
 +  xdg_surface can have at most one role, and may not be assigned any role
 +  not based on xdg_surface.
 +
 +  A role must be assigned before any other requests are made to the
 +  xdg_surface object.
 +
 +  The client must call wl_surface.commit on the corresponding wl_surface
 +  for the xdg_surface state to take effect.
 +
 +  Creating an xdg_surface from a wl_surface which has a buffer attached or
 +  committed is a client error, and any attempts by a client to attach or
 +  manipulate a buffer prior to the first xdg_surface.configure call must
 +  also be treated as errors.
 +
 +  After creating a role-specific object and setting it up, the client must
 +  perform an initial commit without any buffer attached. The compositor
 +  will reply with initial wl_surface state such as
 +  wl_surface.preferred_buffer_scale followed by an xdg_surface.configure
 +  event. The client must acknowledge it and is then allowed to attach a
 +  buffer to map the surface.
 +
 +  Mapping an xdg_surface-based role surface is defined as making it
 +  possible for the surface to be shown by the compositor. Note that
 +  a mapped surface is not guaranteed to be visible once it is mapped.
 +
 +  For an xdg_surface to be mapped by the compositor, the following
 +  conditions must be met:
 +  $(LPAREN)1$(RPAREN) the client has assigned an xdg_surface-based role to the surface
 +  $(LPAREN)2$(RPAREN) the client has set and committed the xdg_surface state and the
 +  	  role-dependent state to the surface
 +  $(LPAREN)3$(RPAREN) the client has committed a buffer to the surface
 +
 +  A newly-unmapped surface is considered to have met condition $(LPAREN)1$(RPAREN) out
 +  of the 3 required conditions for mapping a surface if its role surface
 +  has not been destroyed, i.e. the client must perform the initial commit
 +  again before attaching a buffer.
 +/
final class XdgSurface : WlProxy
{
    /// Version of xdg_shell.xdg_surface
    enum ver = 6;

    /// Build a XdgSurface from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_xdg_surface_listener, cast(void*) this);
    }

    /// Interface object that creates XdgSurface objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return xdgSurfaceIface;
    }

    /// Op-code of XdgSurface.destroy.
    enum destroyOpCode = 0;
    /// Op-code of XdgSurface.getToplevel.
    enum getToplevelOpCode = 1;
    /// Op-code of XdgSurface.getPopup.
    enum getPopupOpCode = 2;
    /// Op-code of XdgSurface.setWindowGeometry.
    enum setWindowGeometryOpCode = 3;
    /// Op-code of XdgSurface.ackConfigure.
    enum ackConfigureOpCode = 4;

    /// Version of xdg_shell protocol introducing XdgSurface.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgSurface.getToplevel.
    enum getToplevelSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgSurface.getPopup.
    enum getPopupSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgSurface.setWindowGeometry.
    enum setWindowGeometrySinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgSurface.ackConfigure.
    enum ackConfigureSinceVersion = 1;

    /// xdg_shell protocol version introducing XdgSurface.onConfigure.
    enum onConfigureSinceVersion = 1;

    /// Event delegate signature of XdgSurface.onConfigure.
    alias OnConfigureEventDg = void delegate(XdgSurface xdgSurface,
                                             uint serial);

    enum Error : uint
    {
        /// Surface was not fully constructed
        notConstructed = 1,
        /// Surface was already constructed
        alreadyConstructed = 2,
        /// Attaching a buffer to an unconfigured surface
        unconfiguredBuffer = 3,
        /// Invalid serial number when acking a configure event
        invalidSerial = 4,
        /// Width or height was zero or negative
        invalidSize = 5,
        /// Surface was destroyed before its role object
        defunctRoleObject = 6,
    }

    /++
     +  destroy the xdg_surface
     +
     +  Destroy the xdg_surface object. An xdg_surface must only be destroyed
     +  after its role object has been destroyed, otherwise
     +  a defunct_role_object error is raised.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  assign the xdg_toplevel surface role
     +
     +  This creates an xdg_toplevel object for the given xdg_surface and gives
     +  the associated wl_surface the xdg_toplevel role.
     +
     +  See the documentation of xdg_toplevel for more details about what an
     +  xdg_toplevel is and how it is used.
     +/
    XdgToplevel getToplevel()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getToplevelOpCode, XdgToplevel.iface.native, null
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(XdgToplevel)_p;
        return new XdgToplevel(_pp);
    }

    /++
     +  assign the xdg_popup surface role
     +
     +  This creates an xdg_popup object for the given xdg_surface and gives
     +  the associated wl_surface the xdg_popup role.
     +
     +  If null is passed as a parent, a parent surface must be specified using
     +  some other protocol, before committing the initial state.
     +
     +  See the documentation of xdg_popup for more details about what an
     +  xdg_popup is and how it is used.
     +/
    XdgPopup getPopup(XdgSurface parent,
                      XdgPositioner positioner)
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getPopupOpCode, XdgPopup.iface.native, null, parent.proxy,
            positioner.proxy
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(XdgPopup)_p;
        return new XdgPopup(_pp);
    }

    /++
     +  set the new window geometry
     +
     +  The window geometry of a surface is its "visible bounds" from the
     +  user's perspective. Client-side decorations often have invisible
     +  portions like drop-shadows which should be ignored for the
     +  purposes of aligning, placing and constraining windows.
     +
     +  The window geometry is double buffered, and will be applied at the
     +  time wl_surface.commit of the corresponding wl_surface is called.
     +
     +  When maintaining a position, the compositor should treat the $(LPAREN)x, y$(RPAREN)
     +  coordinate of the window geometry as the top left corner of the window.
     +  A client changing the $(LPAREN)x, y$(RPAREN) window geometry coordinate should in
     +  general not alter the position of the window.
     +
     +  Once the window geometry of the surface is set, it is not possible to
     +  unset it, and it will remain the same until set_window_geometry is
     +  called again, even if a new subsurface or buffer is attached.
     +
     +  If never set, the value is the full bounds of the surface,
     +  including any subsurfaces. This updates dynamically on every
     +  commit. This unset is meant for extremely simple clients.
     +
     +  The arguments are given in the surface-local coordinate space of
     +  the wl_surface associated with this xdg_surface, and may extend outside
     +  of the wl_surface itself to mark parts of the subsurface tree as part of
     +  the window geometry.
     +
     +  When applied, the effective window geometry will be the set window
     +  geometry clamped to the bounding rectangle of the combined
     +  geometry of the surface of the xdg_surface and the associated
     +  subsurfaces.
     +
     +  The effective geometry will not be recalculated unless a new call to
     +  set_window_geometry is done and the new pending surface state is
     +  subsequently applied.
     +
     +  The width and height of the effective window geometry must be
     +  greater than zero. Setting an invalid size will raise an
     +  invalid_size error.
     +/
    void setWindowGeometry(int x,
                           int y,
                           int width,
                           int height)
    {
        wl_proxy_marshal(
            proxy, setWindowGeometryOpCode, x, y, width, height
        );
    }

    /++
     +  ack a configure event
     +
     +  When a configure event is received, if a client commits the
     +  surface in response to the configure event, then the client
     +  must make an ack_configure request sometime before the commit
     +  request, passing along the serial of the configure event.
     +
     +  For instance, for toplevel surfaces the compositor might use this
     +  information to move a surface to the top left only when the client has
     +  drawn itself for the maximized or fullscreen state.
     +
     +  If the client receives multiple configure events before it
     +  can respond to one, it only has to ack the last configure event.
     +  Acking a configure event that was never sent raises an invalid_serial
     +  error.
     +
     +  A client is not required to commit immediately after sending
     +  an ack_configure request - it may even ack_configure several times
     +  before its next surface commit.
     +
     +  A client may send multiple ack_configure requests before committing, but
     +  only the last request sent before a commit indicates which configure
     +  event the client really is responding to.
     +
     +  Sending an ack_configure request consumes the serial number sent with
     +  the request, as well as serial numbers sent by all configure events
     +  sent on this xdg_surface prior to the configure event referenced by
     +  the committed serial.
     +
     +  It is an error to issue multiple ack_configure requests referencing a
     +  serial from the same configure event, or to issue an ack_configure
     +  request referencing a serial from a configure event issued before the
     +  event identified by the last ack_configure request for the same
     +  xdg_surface. Doing so will raise an invalid_serial error.
     +/
    void ackConfigure(uint serial)
    {
        wl_proxy_marshal(
            proxy, ackConfigureOpCode, serial
        );
    }

    /++
     +  suggest a surface change
     +
     +  The configure event marks the end of a configure sequence. A configure
     +  sequence is a set of one or more events configuring the state of the
     +  xdg_surface, including the final xdg_surface.configure event.
     +
     +  Where applicable, xdg_surface surface roles will during a configure
     +  sequence extend this event as a latched state sent as events before the
     +  xdg_surface.configure event. Such events should be considered to make up
     +  a set of atomically applied configuration states, where the
     +  xdg_surface.configure commits the accumulated state.
     +
     +  Clients should arrange their surface for the new states, and then send
     +  an ack_configure request with the serial sent in this configure event at
     +  some point before committing the new surface.
     +
     +  If the client receives multiple configure events before it can respond
     +  to one, it is free to discard all but the last event it received.
     +/
    @property void onConfigure(OnConfigureEventDg dg)
    {
        _onConfigure = dg;
    }

    private OnConfigureEventDg _onConfigure;
}

/++
 +  toplevel surface
 +
 +  This interface defines an xdg_surface role which allows a surface to,
 +  among other things, set window-like properties such as maximize,
 +  fullscreen, and minimize, set application-specific metadata like title and
 +  id, and well as trigger user interactive operations such as interactive
 +  resize and move.
 +
 +  A xdg_toplevel by default is responsible for providing the full intended
 +  visual representation of the toplevel, which depending on the window
 +  state, may mean things like a title bar, window controls and drop shadow.
 +
 +  Unmapping an xdg_toplevel means that the surface cannot be shown
 +  by the compositor until it is explicitly mapped again.
 +  All active operations $(LPAREN)e.g., move, resize$(RPAREN) are canceled and all
 +  attributes $(LPAREN)e.g. title, state, stacking, ...$(RPAREN) are discarded for
 +  an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
 +  the state it had right after xdg_surface.get_toplevel. The client
 +  can re-map the toplevel by perfoming a commit without any buffer
 +  attached, waiting for a configure event and handling it as usual $(LPAREN)see
 +  xdg_surface description$(RPAREN).
 +
 +  Attaching a null buffer to a toplevel unmaps the surface.
 +/
final class XdgToplevel : WlProxy
{
    /// Version of xdg_shell.xdg_toplevel
    enum ver = 6;

    /// Build a XdgToplevel from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_xdg_toplevel_listener, cast(void*) this);
    }

    /// Interface object that creates XdgToplevel objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return xdgToplevelIface;
    }

    /// Op-code of XdgToplevel.destroy.
    enum destroyOpCode = 0;
    /// Op-code of XdgToplevel.setParent.
    enum setParentOpCode = 1;
    /// Op-code of XdgToplevel.setTitle.
    enum setTitleOpCode = 2;
    /// Op-code of XdgToplevel.setAppId.
    enum setAppIdOpCode = 3;
    /// Op-code of XdgToplevel.showWindowMenu.
    enum showWindowMenuOpCode = 4;
    /// Op-code of XdgToplevel.move.
    enum moveOpCode = 5;
    /// Op-code of XdgToplevel.resize.
    enum resizeOpCode = 6;
    /// Op-code of XdgToplevel.setMaxSize.
    enum setMaxSizeOpCode = 7;
    /// Op-code of XdgToplevel.setMinSize.
    enum setMinSizeOpCode = 8;
    /// Op-code of XdgToplevel.setMaximized.
    enum setMaximizedOpCode = 9;
    /// Op-code of XdgToplevel.unsetMaximized.
    enum unsetMaximizedOpCode = 10;
    /// Op-code of XdgToplevel.setFullscreen.
    enum setFullscreenOpCode = 11;
    /// Op-code of XdgToplevel.unsetFullscreen.
    enum unsetFullscreenOpCode = 12;
    /// Op-code of XdgToplevel.setMinimized.
    enum setMinimizedOpCode = 13;

    /// Version of xdg_shell protocol introducing XdgToplevel.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgToplevel.setParent.
    enum setParentSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgToplevel.setTitle.
    enum setTitleSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgToplevel.setAppId.
    enum setAppIdSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgToplevel.showWindowMenu.
    enum showWindowMenuSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgToplevel.move.
    enum moveSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgToplevel.resize.
    enum resizeSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgToplevel.setMaxSize.
    enum setMaxSizeSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgToplevel.setMinSize.
    enum setMinSizeSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgToplevel.setMaximized.
    enum setMaximizedSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgToplevel.unsetMaximized.
    enum unsetMaximizedSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgToplevel.setFullscreen.
    enum setFullscreenSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgToplevel.unsetFullscreen.
    enum unsetFullscreenSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgToplevel.setMinimized.
    enum setMinimizedSinceVersion = 1;

    /// xdg_shell protocol version introducing XdgToplevel.onConfigure.
    enum onConfigureSinceVersion = 1;
    /// xdg_shell protocol version introducing XdgToplevel.onClose.
    enum onCloseSinceVersion = 1;
    /// xdg_shell protocol version introducing XdgToplevel.onConfigureBounds.
    enum onConfigureBoundsSinceVersion = 4;
    /// xdg_shell protocol version introducing XdgToplevel.onWmCapabilities.
    enum onWmCapabilitiesSinceVersion = 5;

    /// Event delegate signature of XdgToplevel.onConfigure.
    alias OnConfigureEventDg = void delegate(XdgToplevel xdgToplevel,
                                             int width,
                                             int height,
                                             wl_array* states);
    /// Event delegate signature of XdgToplevel.onClose.
    alias OnCloseEventDg = void delegate(XdgToplevel xdgToplevel);
    /// Event delegate signature of XdgToplevel.onConfigureBounds.
    alias OnConfigureBoundsEventDg = void delegate(XdgToplevel xdgToplevel,
                                                   int width,
                                                   int height);
    /// Event delegate signature of XdgToplevel.onWmCapabilities.
    alias OnWmCapabilitiesEventDg = void delegate(XdgToplevel xdgToplevel,
                                                  wl_array* capabilities);

    enum Error : uint
    {
        /// provided value is not a valid variant of the resize_edge enum
        invalidResizeEdge = 0,
        /// invalid parent toplevel
        invalidParent = 1,
        /// client provided an invalid min or max size
        invalidSize = 2,
    }

    /++
     +  edge values for resizing
     +
     +  These values are used to indicate which edge of a surface
     +  is being dragged in a resize operation.
     +/
    enum ResizeEdge : uint
    {
        none = 0,
        top = 1,
        bottom = 2,
        left = 4,
        topLeft = 5,
        bottomLeft = 6,
        right = 8,
        topRight = 9,
        bottomRight = 10,
    }

    /++
     +  types of state on the surface
     +
     +  The different state values used on the surface. This is designed for
     +  state values like maximized, fullscreen. It is paired with the
     +  configure event to ensure that both the client and the compositor
     +  setting the state can be synchronized.
     +
     +  States set in this way are double-buffered. They will get applied on
     +  the next commit.
     +/
    enum State : uint
    {
        /// the surface is maximized
        maximized = 1,
        /// the surface is fullscreen
        fullscreen = 2,
        /// the surface is being resized
        resizing = 3,
        /// the surface is now activated
        activated = 4,
        tiledLeft = 5,
        tiledRight = 6,
        tiledTop = 7,
        tiledBottom = 8,
        suspended = 9,
    }

    enum WmCapabilities : uint
    {
        /// show_window_menu is available
        windowMenu = 1,
        /// set_maximized and unset_maximized are available
        maximize = 2,
        /// set_fullscreen and unset_fullscreen are available
        fullscreen = 3,
        /// set_minimized is available
        minimize = 4,
    }

    /++
     +  destroy the xdg_toplevel
     +
     +  This request destroys the role surface and unmaps the surface;
     +  see "Unmapping" behavior in interface section for details.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  set the parent of this surface
     +
     +  Set the "parent" of this surface. This surface should be stacked
     +  above the parent surface and all other ancestor surfaces.
     +
     +  Parent surfaces should be set on dialogs, toolboxes, or other
     +  "auxiliary" surfaces, so that the parent is raised when the dialog
     +  is raised.
     +
     +  Setting a null parent for a child surface unsets its parent. Setting
     +  a null parent for a surface which currently has no parent is a no-op.
     +
     +  Only mapped surfaces can have child surfaces. Setting a parent which
     +  is not mapped is equivalent to setting a null parent. If a surface
     +  becomes unmapped, its children's parent is set to the parent of
     +  the now-unmapped surface. If the now-unmapped surface has no parent,
     +  its children's parent is unset. If the now-unmapped surface becomes
     +  mapped again, its parent-child relationship is not restored.
     +
     +  The parent toplevel must not be one of the child toplevel's
     +  descendants, and the parent must be different from the child toplevel,
     +  otherwise the invalid_parent protocol error is raised.
     +/
    void setParent(XdgToplevel parent)
    {
        wl_proxy_marshal(
            proxy, setParentOpCode, parent.proxy
        );
    }

    /++
     +  set surface title
     +
     +  Set a short title for the surface.
     +
     +  This string may be used to identify the surface in a task bar,
     +  window list, or other user interface elements provided by the
     +  compositor.
     +
     +  The string must be encoded in UTF-8.
     +/
    void setTitle(string title)
    {
        wl_proxy_marshal(
            proxy, setTitleOpCode, toStringz(title)
        );
    }

    /++
     +  set application ID
     +
     +  Set an application identifier for the surface.
     +
     +  The app ID identifies the general class of applications to which
     +  the surface belongs. The compositor can use this to group multiple
     +  surfaces together, or to determine how to launch a new application.
     +
     +  For D-Bus activatable applications, the app ID is used as the D-Bus
     +  service name.
     +
     +  The compositor shell will try to group application surfaces together
     +  by their app ID. As a best practice, it is suggested to select app
     +  ID's that match the basename of the application's .desktop file.
     +  For example, "org.freedesktop.FooViewer" where the .desktop file is
     +  "org.freedesktop.FooViewer.desktop".
     +
     +  Like other properties, a set_app_id request can be sent after the
     +  xdg_toplevel has been mapped to update the property.
     +
     +  See the desktop-entry specification [0] for more details on
     +  application identifiers and how they relate to well-known D-Bus
     +  names and .desktop files.
     +
     +  [0] https://standards.freedesktop.org/desktop-entry-spec/
     +/
    void setAppId(string appId)
    {
        wl_proxy_marshal(
            proxy, setAppIdOpCode, toStringz(appId)
        );
    }

    /++
     +  show the window menu
     +
     +  Clients implementing client-side decorations might want to show
     +  a context menu when right-clicking on the decorations, giving the
     +  user a menu that they can use to maximize or minimize the window.
     +
     +  This request asks the compositor to pop up such a window menu at
     +  the given position, relative to the local surface coordinates of
     +  the parent surface. There are no guarantees as to what menu items
     +  the window menu contains, or even if a window menu will be drawn
     +  at all.
     +
     +  This request must be used in response to some sort of user action
     +  like a button press, key press, or touch down event.
     +/
    void showWindowMenu(WlSeat seat,
                        uint serial,
                        int x,
                        int y)
    {
        wl_proxy_marshal(
            proxy, showWindowMenuOpCode, seat.proxy, serial, x, y
        );
    }

    /++
     +  start an interactive move
     +
     +  Start an interactive, user-driven move of the surface.
     +
     +  This request must be used in response to some sort of user action
     +  like a button press, key press, or touch down event. The passed
     +  serial is used to determine the type of interactive move $(LPAREN)touch,
     +  pointer, etc$(RPAREN).
     +
     +  The server may ignore move requests depending on the state of
     +  the surface $(LPAREN)e.g. fullscreen or maximized$(RPAREN), or if the passed serial
     +  is no longer valid.
     +
     +  If triggered, the surface will lose the focus of the device
     +  $(LPAREN)wl_pointer, wl_touch, etc$(RPAREN) used for the move. It is up to the
     +  compositor to visually indicate that the move is taking place, such as
     +  updating a pointer cursor, during the move. There is no guarantee
     +  that the device focus will return when the move is completed.
     +/
    void move(WlSeat seat,
              uint serial)
    {
        wl_proxy_marshal(
            proxy, moveOpCode, seat.proxy, serial
        );
    }

    /++
     +  start an interactive resize
     +
     +  Start a user-driven, interactive resize of the surface.
     +
     +  This request must be used in response to some sort of user action
     +  like a button press, key press, or touch down event. The passed
     +  serial is used to determine the type of interactive resize $(LPAREN)touch,
     +  pointer, etc$(RPAREN).
     +
     +  The server may ignore resize requests depending on the state of
     +  the surface $(LPAREN)e.g. fullscreen or maximized$(RPAREN).
     +
     +  If triggered, the client will receive configure events with the
     +  "resize" state enum value and the expected sizes. See the "resize"
     +  enum value for more details about what is required. The client
     +  must also acknowledge configure events using "ack_configure". After
     +  the resize is completed, the client will receive another "configure"
     +  event without the resize state.
     +
     +  If triggered, the surface also will lose the focus of the device
     +  $(LPAREN)wl_pointer, wl_touch, etc$(RPAREN) used for the resize. It is up to the
     +  compositor to visually indicate that the resize is taking place,
     +  such as updating a pointer cursor, during the resize. There is no
     +  guarantee that the device focus will return when the resize is
     +  completed.
     +
     +  The edges parameter specifies how the surface should be resized, and
     +  is one of the values of the resize_edge enum. Values not matching
     +  a variant of the enum will cause the invalid_resize_edge protocol error.
     +  The compositor may use this information to update the surface position
     +  for example when dragging the top left corner. The compositor may also
     +  use this information to adapt its behavior, e.g. choose an appropriate
     +  cursor image.
     +/
    void resize(WlSeat seat,
                uint serial,
                ResizeEdge edges)
    {
        wl_proxy_marshal(
            proxy, resizeOpCode, seat.proxy, serial, edges
        );
    }

    /++
     +  set the maximum size
     +
     +  Set a maximum size for the window.
     +
     +  The client can specify a maximum size so that the compositor does
     +  not try to configure the window beyond this size.
     +
     +  The width and height arguments are in window geometry coordinates.
     +  See xdg_surface.set_window_geometry.
     +
     +  Values set in this way are double-buffered. They will get applied
     +  on the next commit.
     +
     +  The compositor can use this information to allow or disallow
     +  different states like maximize or fullscreen and draw accurate
     +  animations.
     +
     +  Similarly, a tiling window manager may use this information to
     +  place and resize client windows in a more effective way.
     +
     +  The client should not rely on the compositor to obey the maximum
     +  size. The compositor may decide to ignore the values set by the
     +  client and request a larger size.
     +
     +  If never set, or a value of zero in the request, means that the
     +  client has no expected maximum size in the given dimension.
     +  As a result, a client wishing to reset the maximum size
     +  to an unspecified state can use zero for width and height in the
     +  request.
     +
     +  Requesting a maximum size to be smaller than the minimum size of
     +  a surface is illegal and will result in an invalid_size error.
     +
     +  The width and height must be greater than or equal to zero. Using
     +  strictly negative values for width or height will result in a
     +  invalid_size error.
     +/
    void setMaxSize(int width,
                    int height)
    {
        wl_proxy_marshal(
            proxy, setMaxSizeOpCode, width, height
        );
    }

    /++
     +  set the minimum size
     +
     +  Set a minimum size for the window.
     +
     +  The client can specify a minimum size so that the compositor does
     +  not try to configure the window below this size.
     +
     +  The width and height arguments are in window geometry coordinates.
     +  See xdg_surface.set_window_geometry.
     +
     +  Values set in this way are double-buffered. They will get applied
     +  on the next commit.
     +
     +  The compositor can use this information to allow or disallow
     +  different states like maximize or fullscreen and draw accurate
     +  animations.
     +
     +  Similarly, a tiling window manager may use this information to
     +  place and resize client windows in a more effective way.
     +
     +  The client should not rely on the compositor to obey the minimum
     +  size. The compositor may decide to ignore the values set by the
     +  client and request a smaller size.
     +
     +  If never set, or a value of zero in the request, means that the
     +  client has no expected minimum size in the given dimension.
     +  As a result, a client wishing to reset the minimum size
     +  to an unspecified state can use zero for width and height in the
     +  request.
     +
     +  Requesting a minimum size to be larger than the maximum size of
     +  a surface is illegal and will result in an invalid_size error.
     +
     +  The width and height must be greater than or equal to zero. Using
     +  strictly negative values for width and height will result in a
     +  invalid_size error.
     +/
    void setMinSize(int width,
                    int height)
    {
        wl_proxy_marshal(
            proxy, setMinSizeOpCode, width, height
        );
    }

    /++
     +  maximize the window
     +
     +  Maximize the surface.
     +
     +  After requesting that the surface should be maximized, the compositor
     +  will respond by emitting a configure event. Whether this configure
     +  actually sets the window maximized is subject to compositor policies.
     +  The client must then update its content, drawing in the configured
     +  state. The client must also acknowledge the configure when committing
     +  the new content $(LPAREN)see ack_configure$(RPAREN).
     +
     +  It is up to the compositor to decide how and where to maximize the
     +  surface, for example which output and what region of the screen should
     +  be used.
     +
     +  If the surface was already maximized, the compositor will still emit
     +  a configure event with the "maximized" state.
     +
     +  If the surface is in a fullscreen state, this request has no direct
     +  effect. It may alter the state the surface is returned to when
     +  unmaximized unless overridden by the compositor.
     +/
    void setMaximized()
    {
        wl_proxy_marshal(
            proxy, setMaximizedOpCode
        );
    }

    /++
     +  unmaximize the window
     +
     +  Unmaximize the surface.
     +
     +  After requesting that the surface should be unmaximized, the compositor
     +  will respond by emitting a configure event. Whether this actually
     +  un-maximizes the window is subject to compositor policies.
     +  If available and applicable, the compositor will include the window
     +  geometry dimensions the window had prior to being maximized in the
     +  configure event. The client must then update its content, drawing it in
     +  the configured state. The client must also acknowledge the configure
     +  when committing the new content $(LPAREN)see ack_configure$(RPAREN).
     +
     +  It is up to the compositor to position the surface after it was
     +  unmaximized; usually the position the surface had before maximizing, if
     +  applicable.
     +
     +  If the surface was already not maximized, the compositor will still
     +  emit a configure event without the "maximized" state.
     +
     +  If the surface is in a fullscreen state, this request has no direct
     +  effect. It may alter the state the surface is returned to when
     +  unmaximized unless overridden by the compositor.
     +/
    void unsetMaximized()
    {
        wl_proxy_marshal(
            proxy, unsetMaximizedOpCode
        );
    }

    /++
     +  set the window as fullscreen on an output
     +
     +  Make the surface fullscreen.
     +
     +  After requesting that the surface should be fullscreened, the
     +  compositor will respond by emitting a configure event. Whether the
     +  client is actually put into a fullscreen state is subject to compositor
     +  policies. The client must also acknowledge the configure when
     +  committing the new content $(LPAREN)see ack_configure$(RPAREN).
     +
     +  The output passed by the request indicates the client's preference as
     +  to which display it should be set fullscreen on. If this value is NULL,
     +  it's up to the compositor to choose which display will be used to map
     +  this surface.
     +
     +  If the surface doesn't cover the whole output, the compositor will
     +  position the surface in the center of the output and compensate with
     +  with border fill covering the rest of the output. The content of the
     +  border fill is undefined, but should be assumed to be in some way that
     +  attempts to blend into the surrounding area $(LPAREN)e.g. solid black$(RPAREN).
     +
     +  If the fullscreened surface is not opaque, the compositor must make
     +  sure that other screen content not part of the same surface tree $(LPAREN)made
     +  up of subsurfaces, popups or similarly coupled surfaces$(RPAREN) are not
     +  visible below the fullscreened surface.
     +/
    void setFullscreen(WlOutput output)
    {
        wl_proxy_marshal(
            proxy, setFullscreenOpCode, output.proxy
        );
    }

    /++
     +  unset the window as fullscreen
     +
     +  Make the surface no longer fullscreen.
     +
     +  After requesting that the surface should be unfullscreened, the
     +  compositor will respond by emitting a configure event.
     +  Whether this actually removes the fullscreen state of the client is
     +  subject to compositor policies.
     +
     +  Making a surface unfullscreen sets states for the surface based on the following:
     +  * the state$(LPAREN)s$(RPAREN) it may have had before becoming fullscreen
     +  * any state$(LPAREN)s$(RPAREN) decided by the compositor
     +  * any state$(LPAREN)s$(RPAREN) requested by the client while the surface was fullscreen
     +
     +  The compositor may include the previous window geometry dimensions in
     +  the configure event, if applicable.
     +
     +  The client must also acknowledge the configure when committing the new
     +  content $(LPAREN)see ack_configure$(RPAREN).
     +/
    void unsetFullscreen()
    {
        wl_proxy_marshal(
            proxy, unsetFullscreenOpCode
        );
    }

    /++
     +  set the window as minimized
     +
     +  Request that the compositor minimize your surface. There is no
     +  way to know if the surface is currently minimized, nor is there
     +  any way to unset minimization on this surface.
     +
     +  If you are looking to throttle redrawing when minimized, please
     +  instead use the wl_surface.frame event for this, as this will
     +  also work with live previews on windows in Alt-Tab, Expose or
     +  similar compositor features.
     +/
    void setMinimized()
    {
        wl_proxy_marshal(
            proxy, setMinimizedOpCode
        );
    }

    /++
     +  suggest a surface change
     +
     +  This configure event asks the client to resize its toplevel surface or
     +  to change its state. The configured state should not be applied
     +  immediately. See xdg_surface.configure for details.
     +
     +  The width and height arguments specify a hint to the window
     +  about how its surface should be resized in window geometry
     +  coordinates. See set_window_geometry.
     +
     +  If the width or height arguments are zero, it means the client
     +  should decide its own window dimension. This may happen when the
     +  compositor needs to configure the state of the surface but doesn't
     +  have any information about any previous or expected dimension.
     +
     +  The states listed in the event specify how the width/height
     +  arguments should be interpreted, and possibly how it should be
     +  drawn.
     +
     +  Clients must send an ack_configure in response to this event. See
     +  xdg_surface.configure and xdg_surface.ack_configure for details.
     +/
    @property void onConfigure(OnConfigureEventDg dg)
    {
        _onConfigure = dg;
    }

    /++
     +  surface wants to be closed
     +
     +  The close event is sent by the compositor when the user
     +  wants the surface to be closed. This should be equivalent to
     +  the user clicking the close button in client-side decorations,
     +  if your application has any.
     +
     +  This is only a request that the user intends to close the
     +  window. The client may choose to ignore this request, or show
     +  a dialog to ask the user to save their data, etc.
     +/
    @property void onClose(OnCloseEventDg dg)
    {
        _onClose = dg;
    }

    /++
     +  recommended window geometry bounds
     +
     +  The configure_bounds event may be sent prior to a xdg_toplevel.configure
     +  event to communicate the bounds a window geometry size is recommended
     +  to constrain to.
     +
     +  The passed width and height are in surface coordinate space. If width
     +  and height are 0, it means bounds is unknown and equivalent to as if no
     +  configure_bounds event was ever sent for this surface.
     +
     +  The bounds can for example correspond to the size of a monitor excluding
     +  any panels or other shell components, so that a surface isn't created in
     +  a way that it cannot fit.
     +
     +  The bounds may change at any point, and in such a case, a new
     +  xdg_toplevel.configure_bounds will be sent, followed by
     +  xdg_toplevel.configure and xdg_surface.configure.
     +/
    @property void onConfigureBounds(OnConfigureBoundsEventDg dg)
    {
        _onConfigureBounds = dg;
    }

    /++
     +  compositor capabilities
     +
     +  This event advertises the capabilities supported by the compositor. If
     +  a capability isn't supported, clients should hide or disable the UI
     +  elements that expose this functionality. For instance, if the
     +  compositor doesn't advertise support for minimized toplevels, a button
     +  triggering the set_minimized request should not be displayed.
     +
     +  The compositor will ignore requests it doesn't support. For instance,
     +  a compositor which doesn't advertise support for minimized will ignore
     +  set_minimized requests.
     +
     +  Compositors must send this event once before the first
     +  xdg_surface.configure event. When the capabilities change, compositors
     +  must send this event again and then send an xdg_surface.configure
     +  event.
     +
     +  The configured state should not be applied immediately. See
     +  xdg_surface.configure for details.
     +
     +  The capabilities are sent as an array of 32-bit unsigned integers in
     +  native endianness.
     +/
    @property void onWmCapabilities(OnWmCapabilitiesEventDg dg)
    {
        _onWmCapabilities = dg;
    }

    private OnConfigureEventDg _onConfigure;
    private OnCloseEventDg _onClose;
    private OnConfigureBoundsEventDg _onConfigureBounds;
    private OnWmCapabilitiesEventDg _onWmCapabilities;
}

/++
 +  short-lived, popup surfaces for menus
 +
 +  A popup surface is a short-lived, temporary surface. It can be used to
 +  implement for example menus, popovers, tooltips and other similar user
 +  interface concepts.
 +
 +  A popup can be made to take an explicit grab. See xdg_popup.grab for
 +  details.
 +
 +  When the popup is dismissed, a popup_done event will be sent out, and at
 +  the same time the surface will be unmapped. See the xdg_popup.popup_done
 +  event for details.
 +
 +  Explicitly destroying the xdg_popup object will also dismiss the popup and
 +  unmap the surface. Clients that want to dismiss the popup when another
 +  surface of their own is clicked should dismiss the popup using the destroy
 +  request.
 +
 +  A newly created xdg_popup will be stacked on top of all previously created
 +  xdg_popup surfaces associated with the same xdg_toplevel.
 +
 +  The parent of an xdg_popup must be mapped $(LPAREN)see the xdg_surface
 +  description$(RPAREN) before the xdg_popup itself.
 +
 +  The client must call wl_surface.commit on the corresponding wl_surface
 +  for the xdg_popup state to take effect.
 +/
final class XdgPopup : WlProxy
{
    /// Version of xdg_shell.xdg_popup
    enum ver = 6;

    /// Build a XdgPopup from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_xdg_popup_listener, cast(void*) this);
    }

    /// Interface object that creates XdgPopup objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return xdgPopupIface;
    }

    /// Op-code of XdgPopup.destroy.
    enum destroyOpCode = 0;
    /// Op-code of XdgPopup.grab.
    enum grabOpCode = 1;
    /// Op-code of XdgPopup.reposition.
    enum repositionOpCode = 2;

    /// Version of xdg_shell protocol introducing XdgPopup.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgPopup.grab.
    enum grabSinceVersion = 1;
    /// Version of xdg_shell protocol introducing XdgPopup.reposition.
    enum repositionSinceVersion = 3;

    /// xdg_shell protocol version introducing XdgPopup.onConfigure.
    enum onConfigureSinceVersion = 1;
    /// xdg_shell protocol version introducing XdgPopup.onPopupDone.
    enum onPopupDoneSinceVersion = 1;
    /// xdg_shell protocol version introducing XdgPopup.onRepositioned.
    enum onRepositionedSinceVersion = 3;

    /// Event delegate signature of XdgPopup.onConfigure.
    alias OnConfigureEventDg = void delegate(XdgPopup xdgPopup,
                                             int x,
                                             int y,
                                             int width,
                                             int height);
    /// Event delegate signature of XdgPopup.onPopupDone.
    alias OnPopupDoneEventDg = void delegate(XdgPopup xdgPopup);
    /// Event delegate signature of XdgPopup.onRepositioned.
    alias OnRepositionedEventDg = void delegate(XdgPopup xdgPopup,
                                                uint token);

    enum Error : uint
    {
        /// tried to grab after being mapped
        invalidGrab = 0,
    }

    /++
     +  remove xdg_popup interface
     +
     +  This destroys the popup. Explicitly destroying the xdg_popup
     +  object will also dismiss the popup, and unmap the surface.
     +
     +  If this xdg_popup is not the "topmost" popup, the
     +  xdg_wm_base.not_the_topmost_popup protocol error will be sent.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  make the popup take an explicit grab
     +
     +  This request makes the created popup take an explicit grab. An explicit
     +  grab will be dismissed when the user dismisses the popup, or when the
     +  client destroys the xdg_popup. This can be done by the user clicking
     +  outside the surface, using the keyboard, or even locking the screen
     +  through closing the lid or a timeout.
     +
     +  If the compositor denies the grab, the popup will be immediately
     +  dismissed.
     +
     +  This request must be used in response to some sort of user action like a
     +  button press, key press, or touch down event. The serial number of the
     +  event should be passed as 'serial'.
     +
     +  The parent of a grabbing popup must either be an xdg_toplevel surface or
     +  another xdg_popup with an explicit grab. If the parent is another
     +  xdg_popup it means that the popups are nested, with this popup now being
     +  the topmost popup.
     +
     +  Nested popups must be destroyed in the reverse order they were created
     +  in, e.g. the only popup you are allowed to destroy at all times is the
     +  topmost one.
     +
     +  When compositors choose to dismiss a popup, they may dismiss every
     +  nested grabbing popup as well. When a compositor dismisses popups, it
     +  will follow the same dismissing order as required from the client.
     +
     +  If the topmost grabbing popup is destroyed, the grab will be returned to
     +  the parent of the popup, if that parent previously had an explicit grab.
     +
     +  If the parent is a grabbing popup which has already been dismissed, this
     +  popup will be immediately dismissed. If the parent is a popup that did
     +  not take an explicit grab, an error will be raised.
     +
     +  During a popup grab, the client owning the grab will receive pointer
     +  and touch events for all their surfaces as normal $(LPAREN)similar to an
     +  "owner-events" grab in X11 parlance$(RPAREN), while the top most grabbing popup
     +  will always have keyboard focus.
     +/
    void grab(WlSeat seat,
              uint serial)
    {
        wl_proxy_marshal(
            proxy, grabOpCode, seat.proxy, serial
        );
    }

    /++
     +  recalculate the popup's location
     +
     +  Reposition an already-mapped popup. The popup will be placed given the
     +  details in the passed xdg_positioner object, and a
     +  xdg_popup.repositioned followed by xdg_popup.configure and
     +  xdg_surface.configure will be emitted in response. Any parameters set
     +  by the previous positioner will be discarded.
     +
     +  The passed token will be sent in the corresponding
     +  xdg_popup.repositioned event. The new popup position will not take
     +  effect until the corresponding configure event is acknowledged by the
     +  client. See xdg_popup.repositioned for details. The token itself is
     +  opaque, and has no other special meaning.
     +
     +  If multiple reposition requests are sent, the compositor may skip all
     +  but the last one.
     +
     +  If the popup is repositioned in response to a configure event for its
     +  parent, the client should send an xdg_positioner.set_parent_configure
     +  and possibly an xdg_positioner.set_parent_size request to allow the
     +  compositor to properly constrain the popup.
     +
     +  If the popup is repositioned together with a parent that is being
     +  resized, but not in response to a configure event, the client should
     +  send an xdg_positioner.set_parent_size request.
     +/
    void reposition(XdgPositioner positioner,
                    uint token)
    {
        wl_proxy_marshal(
            proxy, repositionOpCode, positioner.proxy, token
        );
    }

    /++
     +  configure the popup surface
     +
     +  This event asks the popup surface to configure itself given the
     +  configuration. The configured state should not be applied immediately.
     +  See xdg_surface.configure for details.
     +
     +  The x and y arguments represent the position the popup was placed at
     +  given the xdg_positioner rule, relative to the upper left corner of the
     +  window geometry of the parent surface.
     +
     +  For version 2 or older, the configure event for an xdg_popup is only
     +  ever sent once for the initial configuration. Starting with version 3,
     +  it may be sent again if the popup is setup with an xdg_positioner with
     +  set_reactive requested, or in response to xdg_popup.reposition requests.
     +/
    @property void onConfigure(OnConfigureEventDg dg)
    {
        _onConfigure = dg;
    }

    /++
     +  popup interaction is done
     +
     +  The popup_done event is sent out when a popup is dismissed by the
     +  compositor. The client should destroy the xdg_popup object at this
     +  point.
     +/
    @property void onPopupDone(OnPopupDoneEventDg dg)
    {
        _onPopupDone = dg;
    }

    /++
     +  signal the completion of a repositioned request
     +
     +  The repositioned event is sent as part of a popup configuration
     +  sequence, together with xdg_popup.configure and lastly
     +  xdg_surface.configure to notify the completion of a reposition request.
     +
     +  The repositioned event is to notify about the completion of a
     +  xdg_popup.reposition request. The token argument is the token passed
     +  in the xdg_popup.reposition request.
     +
     +  Immediately after this event is emitted, xdg_popup.configure and
     +  xdg_surface.configure will be sent with the updated size and position,
     +  as well as a new configure serial.
     +
     +  The client should optionally update the content of the popup, but must
     +  acknowledge the new popup configuration for the new position to take
     +  effect. See xdg_surface.ack_configure for details.
     +/
    @property void onRepositioned(OnRepositionedEventDg dg)
    {
        _onRepositioned = dg;
    }

    private OnConfigureEventDg _onConfigure;
    private OnPopupDoneEventDg _onPopupDone;
    private OnRepositionedEventDg _onRepositioned;
}

private:

immutable WlProxyInterface xdgWmBaseIface;
immutable WlProxyInterface xdgPositionerIface;
immutable WlProxyInterface xdgSurfaceIface;
immutable WlProxyInterface xdgToplevelIface;
immutable WlProxyInterface xdgPopupIface;

immutable final class XdgWmBaseIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new XdgWmBase(proxy);
    }
}

immutable final class XdgPositionerIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new XdgPositioner(proxy);
    }
}

immutable final class XdgSurfaceIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new XdgSurface(proxy);
    }
}

immutable final class XdgToplevelIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new XdgToplevel(proxy);
    }
}

immutable final class XdgPopupIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new XdgPopup(proxy);
    }
}

immutable wl_interface[] wl_ifaces;

enum xdgWmBaseIndex = 0;
enum xdgPositionerIndex = 1;
enum xdgSurfaceIndex = 2;
enum xdgToplevelIndex = 3;
enum xdgPopupIndex = 4;

shared static this()
{
    auto ifaces = new wl_interface[5];

    auto msgTypes = [
        null,
        null,
        null,
        null,
        &ifaces[xdgPositionerIndex],
        &ifaces[xdgSurfaceIndex],
        cast(wl_interface*)WlSurface.iface.native,
        &ifaces[xdgToplevelIndex],
        &ifaces[xdgPopupIndex],
        &ifaces[xdgSurfaceIndex],
        &ifaces[xdgPositionerIndex],
        &ifaces[xdgToplevelIndex],
        cast(wl_interface*)WlSeat.iface.native,
        null,
        null,
        null,
        cast(wl_interface*)WlSeat.iface.native,
        null,
        cast(wl_interface*)WlSeat.iface.native,
        null,
        null,
        cast(wl_interface*)WlOutput.iface.native,
        cast(wl_interface*)WlSeat.iface.native,
        null,
        &ifaces[xdgPositionerIndex],
        null,
    ];

    auto xdg_wm_base_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("create_positioner", "n", &msgTypes[4]),
        wl_message("get_xdg_surface", "no", &msgTypes[5]),
        wl_message("pong", "u", &msgTypes[0]),
    ];
    auto xdg_wm_base_events = [
        wl_message("ping", "u", &msgTypes[0]),
    ];
    ifaces[xdgWmBaseIndex].name = "xdg_wm_base";
    ifaces[xdgWmBaseIndex].version_ = 6;
    ifaces[xdgWmBaseIndex].method_count = 4;
    ifaces[xdgWmBaseIndex].methods = xdg_wm_base_requests.ptr;
    ifaces[xdgWmBaseIndex].event_count = 1;
    ifaces[xdgWmBaseIndex].events = xdg_wm_base_events.ptr;

    auto xdg_positioner_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("set_size", "ii", &msgTypes[0]),
        wl_message("set_anchor_rect", "iiii", &msgTypes[0]),
        wl_message("set_anchor", "u", &msgTypes[0]),
        wl_message("set_gravity", "u", &msgTypes[0]),
        wl_message("set_constraint_adjustment", "u", &msgTypes[0]),
        wl_message("set_offset", "ii", &msgTypes[0]),
        wl_message("set_reactive", "3", &msgTypes[0]),
        wl_message("set_parent_size", "3ii", &msgTypes[0]),
        wl_message("set_parent_configure", "3u", &msgTypes[0]),
    ];
    ifaces[xdgPositionerIndex].name = "xdg_positioner";
    ifaces[xdgPositionerIndex].version_ = 6;
    ifaces[xdgPositionerIndex].method_count = 10;
    ifaces[xdgPositionerIndex].methods = xdg_positioner_requests.ptr;

    auto xdg_surface_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("get_toplevel", "n", &msgTypes[7]),
        wl_message("get_popup", "n?oo", &msgTypes[8]),
        wl_message("set_window_geometry", "iiii", &msgTypes[0]),
        wl_message("ack_configure", "u", &msgTypes[0]),
    ];
    auto xdg_surface_events = [
        wl_message("configure", "u", &msgTypes[0]),
    ];
    ifaces[xdgSurfaceIndex].name = "xdg_surface";
    ifaces[xdgSurfaceIndex].version_ = 6;
    ifaces[xdgSurfaceIndex].method_count = 5;
    ifaces[xdgSurfaceIndex].methods = xdg_surface_requests.ptr;
    ifaces[xdgSurfaceIndex].event_count = 1;
    ifaces[xdgSurfaceIndex].events = xdg_surface_events.ptr;

    auto xdg_toplevel_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("set_parent", "?o", &msgTypes[11]),
        wl_message("set_title", "s", &msgTypes[0]),
        wl_message("set_app_id", "s", &msgTypes[0]),
        wl_message("show_window_menu", "ouii", &msgTypes[12]),
        wl_message("move", "ou", &msgTypes[16]),
        wl_message("resize", "ouu", &msgTypes[18]),
        wl_message("set_max_size", "ii", &msgTypes[0]),
        wl_message("set_min_size", "ii", &msgTypes[0]),
        wl_message("set_maximized", "", &msgTypes[0]),
        wl_message("unset_maximized", "", &msgTypes[0]),
        wl_message("set_fullscreen", "?o", &msgTypes[21]),
        wl_message("unset_fullscreen", "", &msgTypes[0]),
        wl_message("set_minimized", "", &msgTypes[0]),
    ];
    auto xdg_toplevel_events = [
        wl_message("configure", "iia", &msgTypes[0]),
        wl_message("close", "", &msgTypes[0]),
        wl_message("configure_bounds", "4ii", &msgTypes[0]),
        wl_message("wm_capabilities", "5a", &msgTypes[0]),
    ];
    ifaces[xdgToplevelIndex].name = "xdg_toplevel";
    ifaces[xdgToplevelIndex].version_ = 6;
    ifaces[xdgToplevelIndex].method_count = 14;
    ifaces[xdgToplevelIndex].methods = xdg_toplevel_requests.ptr;
    ifaces[xdgToplevelIndex].event_count = 4;
    ifaces[xdgToplevelIndex].events = xdg_toplevel_events.ptr;

    auto xdg_popup_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("grab", "ou", &msgTypes[22]),
        wl_message("reposition", "3ou", &msgTypes[24]),
    ];
    auto xdg_popup_events = [
        wl_message("configure", "iiii", &msgTypes[0]),
        wl_message("popup_done", "", &msgTypes[0]),
        wl_message("repositioned", "3u", &msgTypes[0]),
    ];
    ifaces[xdgPopupIndex].name = "xdg_popup";
    ifaces[xdgPopupIndex].version_ = 6;
    ifaces[xdgPopupIndex].method_count = 3;
    ifaces[xdgPopupIndex].methods = xdg_popup_requests.ptr;
    ifaces[xdgPopupIndex].event_count = 3;
    ifaces[xdgPopupIndex].events = xdg_popup_events.ptr;

    import std.exception : assumeUnique;
    wl_ifaces = assumeUnique(ifaces);

    xdgWmBaseIface = new immutable XdgWmBaseIface( &wl_ifaces[xdgWmBaseIndex] );
    xdgPositionerIface = new immutable XdgPositionerIface( &wl_ifaces[xdgPositionerIndex] );
    xdgSurfaceIface = new immutable XdgSurfaceIface( &wl_ifaces[xdgSurfaceIndex] );
    xdgToplevelIface = new immutable XdgToplevelIface( &wl_ifaces[xdgToplevelIndex] );
    xdgPopupIface = new immutable XdgPopupIface( &wl_ifaces[xdgPopupIndex] );
}

extern(C) nothrow
{
    struct xdg_wm_base_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial) ping;
    }

    __gshared wl_d_xdg_wm_base_listener = xdg_wm_base_listener (&wl_d_on_xdg_wm_base_ping);

    void wl_d_on_xdg_wm_base_ping(void* data,
                                  wl_proxy* proxy,
                                  uint serial)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(XdgWmBase)_p;
            assert(_i, "listener stub proxy is not XdgWmBase");
            if (_i._onPing)
            {
                _i._onPing(_i, serial);
            }
        });
    }


    struct xdg_surface_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial) configure;
    }

    __gshared wl_d_xdg_surface_listener = xdg_surface_listener (&wl_d_on_xdg_surface_configure);

    void wl_d_on_xdg_surface_configure(void* data,
                                       wl_proxy* proxy,
                                       uint serial)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(XdgSurface)_p;
            assert(_i, "listener stub proxy is not XdgSurface");
            if (_i._onConfigure)
            {
                _i._onConfigure(_i, serial);
            }
        });
    }

    struct xdg_toplevel_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      int width,
                      int height,
                      wl_array* states) configure;
        void function(void* data,
                      wl_proxy* proxy) close;
        void function(void* data,
                      wl_proxy* proxy,
                      int width,
                      int height) configure_bounds;
        void function(void* data,
                      wl_proxy* proxy,
                      wl_array* capabilities) wm_capabilities;
    }

    __gshared wl_d_xdg_toplevel_listener = xdg_toplevel_listener (&wl_d_on_xdg_toplevel_configure,
                                                                  &wl_d_on_xdg_toplevel_close,
                                                                  &wl_d_on_xdg_toplevel_configure_bounds,
                                                                  &wl_d_on_xdg_toplevel_wm_capabilities);

    void wl_d_on_xdg_toplevel_configure(void* data,
                                        wl_proxy* proxy,
                                        int width,
                                        int height,
                                        wl_array* states)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(XdgToplevel)_p;
            assert(_i, "listener stub proxy is not XdgToplevel");
            if (_i._onConfigure)
            {
                _i._onConfigure(_i, width, height, states);
            }
        });
    }

    void wl_d_on_xdg_toplevel_close(void* data,
                                    wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(XdgToplevel)_p;
            assert(_i, "listener stub proxy is not XdgToplevel");
            if (_i._onClose)
            {
                _i._onClose(_i);
            }
        });
    }

    void wl_d_on_xdg_toplevel_configure_bounds(void* data,
                                               wl_proxy* proxy,
                                               int width,
                                               int height)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(XdgToplevel)_p;
            assert(_i, "listener stub proxy is not XdgToplevel");
            if (_i._onConfigureBounds)
            {
                _i._onConfigureBounds(_i, width, height);
            }
        });
    }

    void wl_d_on_xdg_toplevel_wm_capabilities(void* data,
                                              wl_proxy* proxy,
                                              wl_array* capabilities)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(XdgToplevel)_p;
            assert(_i, "listener stub proxy is not XdgToplevel");
            if (_i._onWmCapabilities)
            {
                _i._onWmCapabilities(_i, capabilities);
            }
        });
    }

    struct xdg_popup_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      int x,
                      int y,
                      int width,
                      int height) configure;
        void function(void* data,
                      wl_proxy* proxy) popup_done;
        void function(void* data,
                      wl_proxy* proxy,
                      uint token) repositioned;
    }

    __gshared wl_d_xdg_popup_listener = xdg_popup_listener (&wl_d_on_xdg_popup_configure,
                                                            &wl_d_on_xdg_popup_popup_done,
                                                            &wl_d_on_xdg_popup_repositioned);

    void wl_d_on_xdg_popup_configure(void* data,
                                     wl_proxy* proxy,
                                     int x,
                                     int y,
                                     int width,
                                     int height)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(XdgPopup)_p;
            assert(_i, "listener stub proxy is not XdgPopup");
            if (_i._onConfigure)
            {
                _i._onConfigure(_i, x, y, width, height);
            }
        });
    }

    void wl_d_on_xdg_popup_popup_done(void* data,
                                      wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(XdgPopup)_p;
            assert(_i, "listener stub proxy is not XdgPopup");
            if (_i._onPopupDone)
            {
                _i._onPopupDone(_i);
            }
        });
    }

    void wl_d_on_xdg_popup_repositioned(void* data,
                                        wl_proxy* proxy,
                                        uint token)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(XdgPopup)_p;
            assert(_i, "listener stub proxy is not XdgPopup");
            if (_i._onRepositioned)
            {
                _i._onRepositioned(_i, token);
            }
        });
    }
}
