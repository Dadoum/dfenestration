/++
 +  Module generated by wayland:scanner-v0.3.1 for viewporter protocol
 +    xml protocol:   viewporter.xml
 +    generated code: client
 +/
module viewporter;
/+
 +  Protocol copyright:
 +
 +  Copyright © 2013-2016 Collabora, Ltd.
 +
 +  Permission is hereby granted, free of charge, to any person obtaining a
 +  copy of this software and associated documentation files (the "Software"),
 +  to deal in the Software without restriction, including without limitation
 +  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 +  and/or sell copies of the Software, and to permit persons to whom the
 +  Software is furnished to do so, subject to the following conditions:
 +
 +  The above copyright notice and this permission notice (including the next
 +  paragraph) shall be included in all copies or substantial portions of the
 +  Software.
 +
 +  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 +  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 +  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 +  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 +  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 +  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 +  DEALINGS IN THE SOFTWARE.
 +/
/+
 +  Bindings copyright:
 +
 +  Copyright © 2017-2019 Rémi Thebault
 +/
import wayland.client;
import wayland.native.client;
import wayland.native.util;
import wayland.util;

import std.exception : enforce;
import std.string : fromStringz, toStringz;

/++
 +  surface cropping and scaling
 +
 +  The global interface exposing surface cropping and scaling
 +  capabilities is used to instantiate an interface extension for a
 +  wl_surface object. This extended interface will then allow
 +  cropping and scaling the surface contents, effectively
 +  disconnecting the direct relationship between the buffer and the
 +  surface size.
 +/
final class WpViewporter : WlProxy
{
    /// Version of viewporter.wp_viewporter
    enum ver = 1;

    /// Build a WpViewporter from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates WpViewporter objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wpViewporterIface;
    }

    /// Op-code of WpViewporter.destroy.
    enum destroyOpCode = 0;
    /// Op-code of WpViewporter.getViewport.
    enum getViewportOpCode = 1;

    /// Version of viewporter protocol introducing WpViewporter.destroy.
    enum destroySinceVersion = 1;
    /// Version of viewporter protocol introducing WpViewporter.getViewport.
    enum getViewportSinceVersion = 1;

    enum Error : uint
    {
        /// the surface already has a viewport object associated
        viewportExists = 0,
    }

    /++
     +  unbind from the cropping and scaling interface
     +
     +  Informs the server that the client will not be using this
     +  protocol object anymore. This does not affect any other objects,
     +  wp_viewport objects included.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  extend surface interface for crop and scale
     +
     +  Instantiate an interface extension for the given wl_surface to
     +  crop and scale its content. If the given wl_surface already has
     +  a wp_viewport object associated, the viewport_exists
     +  protocol error is raised.
     +/
    WpViewport getViewport(WlSurface surface)
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getViewportOpCode, WpViewport.iface.native, null,
            surface.proxy
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WpViewport)_p;
        return new WpViewport(_pp);
    }
}

/++
 +  crop and scale interface to a wl_surface
 +
 +  An additional interface to a wl_surface object, which allows the
 +  client to specify the cropping and scaling of the surface
 +  contents.
 +
 +  This interface works with two concepts: the source rectangle $(LPAREN)src_x,
 +  src_y, src_width, src_height$(RPAREN), and the destination size $(LPAREN)dst_width,
 +  dst_height$(RPAREN). The contents of the source rectangle are scaled to the
 +  destination size, and content outside the source rectangle is ignored.
 +  This state is double-buffered, see wl_surface.commit.
 +
 +  The two parts of crop and scale state are independent: the source
 +  rectangle, and the destination size. Initially both are unset, that
 +  is, no scaling is applied. The whole of the current wl_buffer is
 +  used as the source, and the surface size is as defined in
 +  wl_surface.attach.
 +
 +  If the destination size is set, it causes the surface size to become
 +  dst_width, dst_height. The source $(LPAREN)rectangle$(RPAREN) is scaled to exactly
 +  this size. This overrides whatever the attached wl_buffer size is,
 +  unless the wl_buffer is NULL. If the wl_buffer is NULL, the surface
 +  has no content and therefore no size. Otherwise, the size is always
 +  at least 1x1 in surface local coordinates.
 +
 +  If the source rectangle is set, it defines what area of the wl_buffer is
 +  taken as the source. If the source rectangle is set and the destination
 +  size is not set, then src_width and src_height must be integers, and the
 +  surface size becomes the source rectangle size. This results in cropping
 +  without scaling. If src_width or src_height are not integers and
 +  destination size is not set, the bad_size protocol error is raised when
 +  the surface state is applied.
 +
 +  The coordinate transformations from buffer pixel coordinates up to
 +  the surface-local coordinates happen in the following order:
 +    1. buffer_transform $(LPAREN)wl_surface.set_buffer_transform$(RPAREN)
 +    2. buffer_scale $(LPAREN)wl_surface.set_buffer_scale$(RPAREN)
 +    3. crop and scale $(LPAREN)wp_viewport.set*$(RPAREN)
 +  This means, that the source rectangle coordinates of crop and scale
 +  are given in the coordinates after the buffer transform and scale,
 +  i.e. in the coordinates that would be the surface-local coordinates
 +  if the crop and scale was not applied.
 +
 +  If src_x or src_y are negative, the bad_value protocol error is raised.
 +  Otherwise, if the source rectangle is partially or completely outside of
 +  the non-NULL wl_buffer, then the out_of_buffer protocol error is raised
 +  when the surface state is applied. A NULL wl_buffer does not raise the
 +  out_of_buffer error.
 +
 +  If the wl_surface associated with the wp_viewport is destroyed,
 +  all wp_viewport requests except 'destroy' raise the protocol error
 +  no_surface.
 +
 +  If the wp_viewport object is destroyed, the crop and scale
 +  state is removed from the wl_surface. The change will be applied
 +  on the next wl_surface.commit.
 +/
final class WpViewport : WlProxy
{
    /// Version of viewporter.wp_viewport
    enum ver = 1;

    /// Build a WpViewport from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates WpViewport objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wpViewportIface;
    }

    /// Op-code of WpViewport.destroy.
    enum destroyOpCode = 0;
    /// Op-code of WpViewport.setSource.
    enum setSourceOpCode = 1;
    /// Op-code of WpViewport.setDestination.
    enum setDestinationOpCode = 2;

    /// Version of viewporter protocol introducing WpViewport.destroy.
    enum destroySinceVersion = 1;
    /// Version of viewporter protocol introducing WpViewport.setSource.
    enum setSourceSinceVersion = 1;
    /// Version of viewporter protocol introducing WpViewport.setDestination.
    enum setDestinationSinceVersion = 1;

    enum Error : uint
    {
        /// negative or zero values in width or height
        badValue = 0,
        /// destination size is not integer
        badSize = 1,
        /// source rectangle extends outside of the content area
        outOfBuffer = 2,
        /// the wl_surface was destroyed
        noSurface = 3,
    }

    /++
     +  remove scaling and cropping from the surface
     +
     +  The associated wl_surface's crop and scale state is removed.
     +  The change is applied on the next wl_surface.commit.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  set the source rectangle for cropping
     +
     +  Set the source rectangle of the associated wl_surface. See
     +  wp_viewport for the description, and relation to the wl_buffer
     +  size.
     +
     +  If all of x, y, width and height are -1.0, the source rectangle is
     +  unset instead. Any other set of values where width or height are zero
     +  or negative, or x or y are negative, raise the bad_value protocol
     +  error.
     +
     +  The crop and scale state is double-buffered, see wl_surface.commit.
     +/
    void setSource(WlFixed x,
                   WlFixed y,
                   WlFixed width,
                   WlFixed height)
    {
        wl_proxy_marshal(
            proxy, setSourceOpCode, x.raw, y.raw, width.raw, height.raw
        );
    }

    /++
     +  set the surface size for scaling
     +
     +  Set the destination size of the associated wl_surface. See
     +  wp_viewport for the description, and relation to the wl_buffer
     +  size.
     +
     +  If width is -1 and height is -1, the destination size is unset
     +  instead. Any other pair of values for width and height that
     +  contains zero or negative values raises the bad_value protocol
     +  error.
     +
     +  The crop and scale state is double-buffered, see wl_surface.commit.
     +/
    void setDestination(int width,
                        int height)
    {
        wl_proxy_marshal(
            proxy, setDestinationOpCode, width, height
        );
    }
}

private:

immutable WlProxyInterface wpViewporterIface;
immutable WlProxyInterface wpViewportIface;

immutable final class WpViewporterIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WpViewporter(proxy);
    }
}

immutable final class WpViewportIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WpViewport(proxy);
    }
}

immutable wl_interface[] wl_ifaces;

enum wpViewporterIndex = 0;
enum wpViewportIndex = 1;

shared static this()
{
    auto ifaces = new wl_interface[2];

    auto msgTypes = [
        null,
        null,
        null,
        null,
        &ifaces[wpViewportIndex],
        cast(wl_interface*)WlSurface.iface.native,
    ];

    auto wp_viewporter_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("get_viewport", "no", &msgTypes[4]),
    ];
    ifaces[wpViewporterIndex].name = "wp_viewporter";
    ifaces[wpViewporterIndex].version_ = 1;
    ifaces[wpViewporterIndex].method_count = 2;
    ifaces[wpViewporterIndex].methods = wp_viewporter_requests.ptr;

    auto wp_viewport_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("set_source", "ffff", &msgTypes[0]),
        wl_message("set_destination", "ii", &msgTypes[0]),
    ];
    ifaces[wpViewportIndex].name = "wp_viewport";
    ifaces[wpViewportIndex].version_ = 1;
    ifaces[wpViewportIndex].method_count = 3;
    ifaces[wpViewportIndex].methods = wp_viewport_requests.ptr;

    import std.exception : assumeUnique;
    wl_ifaces = assumeUnique(ifaces);

    wpViewporterIface = new immutable WpViewporterIface( &wl_ifaces[wpViewporterIndex] );
    wpViewportIface = new immutable WpViewportIface( &wl_ifaces[wpViewportIndex] );
}

extern(C) nothrow
{

}
